---
title: 浏览器工作原理的笔记
tags: ["浏览器工作原理"]
创建时间: 星期一, 九月 19日 2022, 10:40:20 晚上
修改时间: 星期三, 一月 11日 2023, 11:11:31 上午
---
#浏览器

# 浏览器工作原理的笔记

## 运行

运行chrome打开一个页面，会执行四个进程。

- GPU
- 网络
- 浏览器
- 页面

## 进程与线程

### 并行处理

单线程是串行执行
多线程可以同时执行(并行处理)

### 线程

线程不能单独存在，它是由进程来**启动和管理的**。

### 进程

一个进程是一个程序的**运行实例**。

启动一个程序时，操作系统会为该程序创建一块内存。用来存放代码、运行中的数据和一个执行任务的主线程。把这个环境称为进程。

### 区分

线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率。

#### 4个特点

1. 进程中任意一个线程执行出错，都会导致整个进程的崩塌。
2. 线程之间共享进程中的数据。
3. 当一个进程关闭后，操作系统会**回收**进程所占用的内存。
4. 进程之间的内容相互隔离。


## 单进程浏览器时代

> 单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里。
> 模块包括: 网络、插件、JavaScript运行环境、渲染引擎和页面等。

### 产生的问题

1. 不稳定

> 早期浏览器借助于插件来实现web视频、web游戏等强大功能。但是插件是最容易出现问题的模块。一个插件的意外崩溃会引起整个浏览器的崩溃。
> 渲染引擎也是不稳定。通常一些复杂的JavaScript代理就有可能引起渲染引起模块的崩溃。

2. 不流畅

> 同一时刻只能有一个模块运行。
> 一个无限循环的JavaScript脚本执行时，它会独占整个线程。这样导致其他运行在该线程中的模块没有机会被执行。

3. 不安全

> 插件可以使用 C/C++ 等代码编写，通过插件可以获取到操作系统的任意资源，当你在页面
运行一个插件时也就意味着这个插件能完全操作你的电脑。


以上这些就是当时浏览器的特点，不稳定，不流畅，而且不安全。这是一段不堪回首的过
去，也许你没有经历过，不过你可以想象一下这样的场景：当你正在用浏览器打开多个页面
时，突然某个页面崩溃了或者失去响应，随之而来的是整个浏览器的崩溃或者无响应。

## 早期多进程浏览器时代

Chrome 的页面是运行在单独的渲染进程中的，同时页面里的插件也是
运行在单独的插件进程之中，而进程之间是通过 IPC 机制进行通信

### 解决不稳定的问题

由于进程是相互隔离的，所以当一个页面或者插件崩溃
时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面，这就
完美地解决了页面或者插件的崩溃会导致整个浏览器崩溃，也就是不稳定的问题。

### 解决不流畅的问题

JavaScript 也是运行在渲染进程中
的，所以即使 JavaScript 阻塞了渲染进程，影响到的也只是当前的渲染页面，而并不会影
响浏览器和其他页面，因为其他页面的脚本是运行在它们自己的渲染进程中的。所以当我们
**再在 Chrome 中运行上面那个死循环的脚本时，没有响应的仅仅是当前的页面**。

> 对于内存泄漏的解决方法那就更简单了，因为当关闭一个页面时，整个渲染进程也会被关
闭，之后该进程所占用的内存都会被系统回收，这样就轻松解决了浏览器页面的内存泄漏问
题。

### 解决不安全的问题

采用多进程架构的额外好处是可以使
用安全沙箱，你可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，
但是不能在你的硬盘上写入任何数据，也不能在敏感位置读取任何数据，例如你的文档和桌
面。Chrome 把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里
面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。


## 目前多进程架构

⚠️upload failed, check dev console

最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个
GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。


- **浏览器进程**。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
- **渲染进程**。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，
排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会
为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
- **GPU 进程**。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷
是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘
制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了
GPU 进程。
- **网络进程**。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面
的，直至最近才独立出来，成为一个单独的进程。
- **插件进程**。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保
证插件进程崩溃不会对浏览器和页面造成影响。


> 打开一个页面，至少4个进程
> - 浏览器进程
> - 网络进程
> - 渲染进程
> - GPU进程
> - (若有装插件，还有插件进程)


### 两面性

> 虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不
可避免地带来了一些问题

1. 更高的资源占用
2. 更复杂的体系架构
> 浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已
经很难适应新的需求了


## 未来面向服务的架构

面向服务的架构(Services Oriented Architecture)(SOA)

> 原来的各种模块会被重构成独立的服务（Service），每个服务（Service）都可以在独立的进程中运行，访问服务（Service）必须使用定义好的接口，通过 IPC 来通信，从而构建一个更内聚、松耦合、易于维护和扩展的系统，更好实现 Chrome 简单、稳定、高速、安全的目标。

Chrome 最终要把 UI、数据库、文件、设备、网络等模块重构为基础服务，类似操作系统
底层服务，下面是 Chrome“面向服务的架构”的进程模型图：

## TCP协议：如何保证页面文件能被完整送达浏览器？

衡量Web页面性能的一个重要指标**FP** (First Paint), 从页面加载到首次开始绘制的时长。

影响FP的一个重要因素：**网络加载速度**。

需要对网络有充分的了解。关键要对网络协议有深刻的认识。HTTP、WebSocket。都是基于TCP/IP


### IP (网络层)

计算机的地址就称为 IP 地址，访问任何网站实际上只是你的计算机向另外一台计算机请求信息。

如果要将一个**数据包**从主机A发给主机B，在传输前，数据包会被附加上主机B的**IP地址信息**，这样在传输的过程中才能正确的寻址。额外地，数据包上还会附加上主机A 本身的 IP 地址，有了这些信息主机 B 才可以回复信息给主机 A。这些附加的信息会被装进一个叫 IP 头的数据结构里。

IP 头是 IP 数据包开头的信息，包含 IP 版本、源 IP 地址、目标 IP 地址、生存时间等信息。

> 知道谁发，和知道发送给谁。

### UDP (传输层)

用户数据包协议（User Datagram Protocol） UDP

UDP 中一个最重要的信息是端口号，端口号其实就是一个数字，每个想访问网络的程序都需要绑定一个端口号。通过端口号 UDP 就能把指定的数据包发送给指定的程序了，所以IP通过 IP 地址信息把数据包发送给指定的电脑，**而 UDP 通过端口号把数据包分发给正确的程序**。

和 IP 头一样，**端口号会被装进 UDP 头里面**，UDP 头再和原始数据包合并组成新的UDP 数据包。UDP 头中除了目的端口，还有源端口号等信息

在使用 UDP 发送数据时，**有各种因素会导致数据包出错**，虽然 UDP 可以校验数据是否正确，**但是对于错误的数据包**，UDP 并不提供重发机制，只是丢弃当前的包，而且 UDP 在发送之后也无法知道是否能达到目的地。

虽说UDP 不能保证数据可靠性，但是传输速度却非常快，所以 UDP 会应用在一些关注速度、但不那么严格要求数据完整性的领域，如在线视频、互动游戏等。

> 不可靠，不能保证数据可靠性，但是速度快。发了就行。UDP有校验，但是对于错误的包，采用丢弃，没有重发机制。

- 数据包在传输过程中容易丢失
- 大文件会被拆分成很多小的数据包来传输，这些小的数据包会经过不同的路由，并在不同的时间到达接收端，而 UDP 协议并不知道如何组装这些数据包，从而把这些数据包还原成完整的文件。

### TCP (传输层)

TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。

- 对于数据包丢失的情况，TCP 提供重传机制；
- TCP 引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。

> 充分解决了UDP带来的问题，但因为做这些事，需要时间。所以速度没有UDP快。

和 UDP 头一样，TCP 头除了包含了目标端口和本机端口号外，还提供了用于**排序的序列号**，以便接收端通过序号来**重排数据包**。

TCP 单个数据包的传输流程和 UDP 流程差不多，不同的地方在于，**通过 TCP 头的信息保证了一块大的数据传输的完整性**。

一个完整的 TCP 连接的生命周期包括了三个阶段。

- 建立连接
- 传输数据
- 断开连接


#### 三次握手(建立连接)

TCP 提供面向连接的通信传输。面向连接是指在数据通信开始之前先做好两端之间的准备工作。所谓三次握手，是指在建立一个 TCP 连接时，客户端和服务器总共要发送三个数据包以确认连接的建立。

#### 传输数据阶段

接收端需要**对每个数据包进行确认操作**，也就是接收端在接收到数据包之后，需要发送确认数据包给发送端。所以当发送端发送了一个数据包之后，在规定时间内没有接收到接收端反馈的确认消息，**则判断为数据包丢失，并触发发送端的重发机制**。同样，一个大的文件在传输过程中会被拆分成很多小的数据包，这些数据包到达接收端后，接收端会按照 TCP 头中的序号为其排序，从而保证组成完整的数据。

#### 四次分手(断开连接)

数据传输完毕之后，就要终止连接了，涉及到最后一个阶段“四次挥手”来保证双方都能断开连接。

TCP 为了保证数据传输的可靠性，牺牲了数据包的传输速度，因为“三次握手”和“数据包校验机制”等把传输过程中的数据包的**数量提高了一倍**。

互联网中的数据是通过数据包来传输的，数据包在传输过程中容易丢失或出错。

- IP 负责把数据包送达目的主机。
- UDP 负责把数据包送达具体应用
- 而 TCP 保证了数据完整地传输，它的连接可分为三个阶段：**建立连接**、**传输数据**和**断开连接**。


## HTTP

HTTP 协议，正是建立在 TCP 连接基础之上的。HTTP 是一种允许**浏览器向服务器获取资源的协议**，是 Web 的基础。

> 允许浏览器向服务器获取资源的协议。 一个应用层的协议。


### 浏览器发起HTTP请求流程

1. 构建请求

   首先，浏览器构建请求行
   ```txt
   GET /index.html HTTP1.1
   ```

2. 查找缓存

   在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。其中，浏览器缓存是**一种在本地保存资源副本**，以供下次请求时直接使用的技术。
   当浏览器发现请求的资源已经在浏览器缓存中存有副本，它会拦截请求，返回该资源的副本，并直接结束请求，**而不会再去源服务器重新下载**。这样做的好处有：
   - 缓解服务器端压力，提升性能（获取资源的耗时更短了）；
   - 对于网站来说，缓存是实现快速资源加载的重要组成部分。
   当然，如果缓存查找失败，就会进入网络请求过程了。

3. 准备IP地址和端口

   HTTP与IP的关系：
   HTTP 协议作为应用层协议，**用来封装请求的文本信息**；并**使用TCP/IP 作传输层协议**将它**发到网络**上，所以在 HTTP 工作开始之前，浏览器需要通过 TCP 与服务器建立连接。

   > HTTP 的内容是通过 TCP 的传输数据阶段来实现的

   倒推法：
   HTTP网络请求建立在TCP连接，而TCP连接的第一步就是需要准备IP和端口号。

   那么获取端口号：DNS(Domain Name System)域名系统：一个服务，负责把域名和 IP 地址做一一映射关系。

   这样一路推导下来，你会发现在第一步浏览器会**请求 DNS 返回域名对应的 IP**。当然浏览器还提供了DNS 数据缓存服务，如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用，这样也会减少一次网络请求。

   拿到 IP 之后，接下来就需要获取端口号了。通常情况下，如果 URL 没有特别指明端口号，那么 HTTP 协议默认是 80 端口。

   > HTTP -> TCP -> IP port -> DNS

4. 等待TCP队列

   现在已经把端口和 IP 地址都准备好了，那么下一步是不是可以建立 TCP 连接了呢？答案依然是“不行”。Chrome 有个机制，**同一个域名同时最多只能建立 6 个 TCP 连接**，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。**当然，如果当前请求数量少于 6，会直接进入下一步，建立 TCP 连接。**

5. 建立TCP连接

   排队等待结束之后，终于可以快乐地和服务器握手了，在 HTTP 工作开始之前，浏览器通过 TCP 与服务器建立连接。而 TCP 的工作方式，我在上一篇文章中已经做过详细介绍了，如果有必要，你可以自行回顾下，这里我就不再重复讲述了。

6. 发起HTTP请求

   一旦建立了 TCP 连接，浏览器就可以和服务器进行通信了。而 HTTP 中的数据正是在这个通信过程中传输的。

   - 请求行
   - 请求头
   - 请求体 (POST)

   首先浏览器会向服务器发送请求行，它包括了**请求方法**、请求 URI（Uniform ResourceIdentifier）和 HTTP 版本协议。

   ```txt
   GET /index.html HTTP1.1
   ```



### 服务器端处理HTTP请求流程

1. 返回请求
   一旦服务器处理结束，便可以返回数据给浏览器了。你可以通过工具软件 curl 来查看返回请求数据，具体使用方法是在命令行中输入以下命令：

   ```bash
    curl -i https://time.geekbang.org/
   ```

> -i是为了返回响应行、响应头和响应体的数据

  - 响应行 (HTTP协议、状态码(2xx、3xx、4xx、5xx))
  - 响应头 (服务器自身的一些信息、服务器要在客户端保存的 Cookie 等信息)
  - 响应体

2. 断开连接
   一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。不过如果浏览器或者服务器在其头信息中加入了

   ```
   Connection:Keep-Alive 
   ```
   那么 TCP 连接在发送后将仍然保持打开状态，这样浏览器就可以继续通过同一个 TCP 连接发送请求。保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。

  比如，一个 Web 页面中内嵌的图片就都来自同一个 Web 站点，如果初始化了一个持久连接，你就可以复用该连接，以请求其他资源，而不需要重新再建立新的 TCP 连接。

3. 重定向
   响应行返回的状态码是 301
   状态 301 就是告诉浏览器，我需要重定向到另外一个网址，而需要重定向的网址正是包含在响应头的 Location 字段中，接下来，浏览器获取 Location 字段中的地址，并使用该地址重新导航，这就是一个完整重定向的执行流程。



### 2个问题

1. 为什么通常在第一次访问一个站点时，打开速度很慢，当再次访问这个站点时，速度就很快了？

2. 当登录过一个网站之后，下次再访问该站点，就已经处于登录状态了，这是怎么做到的呢？





## 导航流程：从输入URL到页面展示，这中间发生了什么？

整个过程需要各个进程之间的配合

先对浏览器进程、渲染进程和网络进程的主要职责有个认知。

- 浏览器进程主要负责**用户交互、子进程管理和文件储存**等功能。
- 网络进程是**面向渲染进程和浏览器进程**等提供网络下载功能。
- 渲染进程的主要职责是把从网络下载的 HTML、JavaScript、CSS、图片等资源**解析为可以显示和交互的页面**。因为渲染进程所有的内容都是通过网络获取的，会存在一些恶意代码利用浏览器漏洞对系统进行攻击，所以运行在渲染进程里面的代码是不被信任的。这也是为什么 **Chrome 会让渲染进程运行在安全沙箱里**，就是为了保证系统的安全。

[[#目前多进程架构]]了解多进程**架构**， 接下来了解URL到页面的流程。

每个进程的职责：

1. 用户在浏览器进程里输入请求信息。
2. 网络进程发起URL请求
3. 服务器响应URL请求后，浏览器进程就开始准备渲染进程
4. 准备渲染进程之后，需要先向渲染进程提交页面数据，这个过程称之为**提交文档**阶段。
5. 渲染进程接收完文档信息后，便开始解析页面和加载子页面，完成页面的渲染。

这其中，用户发出URL到页面开始解析的这个过程，叫做**导航**。


### 从输入 URL 到页面展示

#### 用户输入

1. 用户在地址栏输入查询关键字，地址栏会判断关键字是**搜索内容**还是**请求的URL**
2. 输入完毕按下回车键，浏览器会进入等待提交文档阶段，所以当前页面还是在上一个页面。当提交文档阶段来了，页面内容才会被替换。

#### URL请求过程

浏览器进程通过**进程间通信**(IPC) 把URL请求发送到网络进程， 网络进程接收到URL请求后，会在这里发起真正的URL请求流程。

- 网络进程会查找本地缓存是否缓存了该资源。
   - 如果有的话，直接返回资源给浏览器进程
   - 没有的话，那么进入网络请求流程，请求前第一步建立DNS解析，以获取请求域名的服务器IP地址。(如果是HTTPS协议，那么还需建立TLS链接)
   - 接下来使用IP地址与服务器建立TCP连接。连接建立之后，浏览器端会构建请求行、请求头等信息、并把和该域名相关的Cookie等数据附加到请求头中，然后向服务器发送构建的请求信息。
   - 服务器接收到请求信息，会根据请求信息生成相应数据(响应行、响应体、响应体等信息)，并发送给网络进程。等网络进程接收了相应行和响应头之后，就开始解析响应头的内容了。

#### 重定向

若响应头的状态码为301 or 302，那么说明服务器需要浏览器重定向到其他URL。这时网络进程会从响应头的 Location 字段里面读取重定向的地址，然后再发起新的 HTTP 或者 HTTPS 请求，一切又重头开始了。

浏览器要重新导航到新的地址上。

服务器返回的响应头的状态码是200, 这说明告诉浏览器一切正常，可以继续往下处理该请求。


#### 相应数据类型处理

继续导航流程的分析。URL请求的数据类型，有时候是一个下载类型，有时候是正常的HTML页面。浏览器如何区分？

答案：Content-Type。

Content-Type是HTTP头中非常重要的字段。它告诉浏览器 服务器返回的响应是什么类型。然后浏览器根据Content-Type的值来决定如何显示响应体的内容。

- text/html
- application/octet-stream (字节流类型，通常浏览器会按照下载类型来处理)


> 需要注意的是，如果服务器配置 Content-Type 不正确，比如将 text/html 类型配置成application/octet-stream 类型，那么浏览器可能会曲解文件内容，比如会将一个本来是用来展示的页面，变成了一个下载文件。

如果是下载类型, 那么该请求会被提交给浏览器的下载管理器，同时**该 URL 请求的导航流程就此结束**。但如果是HTML，那么浏览器则会继续进行导航流程。由于 Chrome的页面渲染是运行在**渲染进程**中的，所以接下来就需要准备渲染进程了。

#### 准备渲染进程

默认情况下，Chrome 会为每个页面分配一个渲染进程，也就是说，每打开一个新页面就会配套创建一个新的渲染进程。但是，也有一些例外，在某些情况下，浏览器会让多个页面直接运行在同一个渲染进程中。

那什么情况下多个页面会同时运行在一个渲染进程中呢？

要解决这个问题，我们就需要先了解下什么是**同一站点**（same-site）。具体地讲，我们将“同一站点”定义为**根域名**（例如，geekbang.org）加上**协议**（例如，https:// 或者http://），还包含了该根域名下的所有子域名和不同的端口，比如下面这三个

```txt
https://time.geekbang.org
https://www.geekbang.org
https://www.geekbang.org:8080
```

它们都是属于同一站点，因为它们的协议都是 HTTPS，而且根域名也都是geekbang.org。

Chrome 的默认策略是，每个标签对应一个渲染进程。但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫 process-per-site-instance。

若新页面和当前页面不属于同一个站点。浏览器会创建一个新的渲染进程来处理新页面的渲染。

总的来说，打开一个页面采用的渲染进程策略：

- 通常情况下，打开新的页面都会使用单独的渲染进程；
- 如果从 A 页面打开 B 页面，且 A 和 B 都属于同一站点的话，那么 B 页面复用 A 页面的渲染进程；如果是其他情况，浏览器进程则会为 B 创建一个新的渲染进程。

渲染进程准备好之后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了提交文档阶段。

#### 提交文档

这里的“文档”是指 URL 请求的响应体数据。

- “提交文档”的消息是由浏览器进程发出的，渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”。
- 等**文档数据传输完成**之后，渲染进程会**返回“确认提交”的消息**给浏览器进程。
- 浏览器进程在**收到“确认提交”的消息**后，会**更新浏览器界面状态**，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。

> 这也就解释了为什么在浏览器的地址栏里面输入了一个地址后，之前的页面没有立马消失，而是要加载一会儿才会更新页面。

到这里，一个完整的导航流程就“走”完了，这之后就要进入渲染阶段了。

#### 渲染阶段

一旦文档被提交，渲染进程便开始页面解析和子资源加载了。

这里先了解一旦页面生成完成，渲染进程会发送一个消息给浏览器进程，浏览器接收到消息后，会停止标签图标上的加载动画。


### 总结

- 服务器可以根据响应头来控制浏览器的行为，如跳转、网络数据类型判断。
- Chrome 默认采用每个标签对应一个渲染进程，但是如果两个页面属于同一站点，那这两个标签会使用同一个渲染进程。
- 浏览器的导航过程涵盖了从用户发起请求到提交文档给渲染进程的中间所有阶段。
- 导航流程很重要，它是网络加载流程和渲染流程之间的一座桥梁，如果你理解了导航流程，那么你就能完整串起来整个页面显示流程，这对于你理解浏览器的工作原理起到了点睛的作用。


## 渲染流程

那导航被提交后又会怎么样呢？就进入了渲染阶段。


1. 渲染进程将 HTML 内容转换为能够读懂的DOM 树结构。
2. 渲染引擎将 CSS 样式表转化为浏览器可以理解的styleSheets，计算出 DOM 节点的
样式。
3. 创建布局树，并计算元素的布局信息。
4. 对布局树进行分层，并生成分层树。
5. 为每个图层生成绘制列表，并将其提交到合成线程。
6. **合成线程**将**图层**分成**图块**，并在**光栅化线程池**中将**图块**转换成**位图**。
7. **合成线程**发送绘制图块命令**DrawQuad**给浏览器进程。
8. **浏览器进程**根据 DrawQuad 消息生成页面，并**显示到显示器上**。