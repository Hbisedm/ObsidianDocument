---
title: EsModule的学习的笔记
date: "2022-07-03 20:43:19"
tags: ["EsModule的学习"]
创建时间: 星期三, 七月 27日 2022, 8:58:57 晚上
修改时间: 星期四, 十二月 22日 2022, 11:41:43 中午
---
#EsModule

# EsModule的学习的笔记

> ESModule工作分为3个步骤：构建、实例化、运行
> 构建目的：文件解析为模块记录
> 实例化目的：为模块记录分配空间，然后使得`import`与`export`执行那块内存空间
> 运行目的：为内存空间里面的值填充真实值
> 

## ESM的特效

- 自动采用严格模式，忽略'use strict'
- 每个 ESM 模块都是单独的私有作用域
- ESM 是通过 CORS 去请求外部 JS 模块的
- ESM 的script 标签会延迟执行脚本 

## 模块化的作用

**模块化为你提供了一种更好的方式来组织变量和函数**。你可以把相关的变量和函数放在一起组成一个模块。
这种组织方式会把函数和变量放在**模块作用域**中。模块中的函数可以通过模块作用域来共享变量。
## 模块也是一种作用域

。
## ESModule的工作
1.  **构建**：查找，下载，然后把所有文件解析成模块记录。
2.  **实例化**：为所有模块分配内存空间（此刻还没有填充值），然后依照导出、导入语句把模块指向对应的内存地址。这个过程称为**链接**（Linking）。
3.  **运行**：运行代码，从而把内存空间填充为真实值。

### 构建阶段
做三件事
- 确定依赖从哪里来(模块定位)
- 提取文件，通过==URL下载==或者==文件系统加载==
- ==解析==文件为模块记录

##### 模块实例：解析后的模块记录

而阻塞主线程会使得应用变得卡顿，影响用户体验。这是 ESM 标准把算法分成多个阶段的原因之一。将构建划分为一个独立阶段后，浏览器可以在进入同步的实例化过程之前下载文件然后理解模块关系图。

1. 下载模块
	- 加载器
	- 模块定位符
	- 模块定位算法
		- ESM 和 CJS 之间最主要的区别之一就是，ESM 把算法化为为多个阶段。
		- > - CJS 使用不同的算法是因为它从文件系统加载文件，这耗费的时间远远小于从网络上下载。因此 Node 在加载文件的时候可以阻塞主线程，而不造成太大影响。而且既然文件已经加载完成了，那么它就可以直接进行实例化和运行。所以在 CJS 中实例化和运行并不是两个相互独立的阶段。这也意味着，你可以在返回模块实例之前，顺着整颗依赖树去逐一加载、实例化和运行每一个依赖。
		- **为啥esm不能使用变量导入而cjs可以**因为js会看当前的代码里面有没有`import`，有的话会先创建个==依赖关系图==这个时候会变量提升，但是变量提升还没赋值的时候呢。所以不可以使用变量的方式进行导入
		- 为了在 ESM 中实现这种方式，人们已经提出了一个**动态导入**提案。该提案允许你可以使用类似 ``import(\`${path}/foo.js`)``的导入语句。

这种方式实际上是把使用 `import()` 加载的文件当成了一个入口文件。动态导入的模块会开启一个全新的独立依赖关系树。

> 加载器使用**模块映射**（Module Map）来管理缓存。每个**全局作用域**都在一个单独的模块映射中跟踪其模块。

> 模块映射(fetch(下载) -> 模块记录)

映射表里：多个模块记录

2. 解析模块
	> 注意点：
	> - 按照**严格模式**去解析模块，解析后会维护个模块映射，未来解析模块时，会先去模块映射内看看有没有这个模块，因为cache下来在里面了。
	> - await为顶部保留字，this为undefined
	> - 不同的解析方式称为解析目标(Parse Goal)。不同的解析目标(方式)解析同一个文件会得到不同的结果


### 实例化阶段

为模块分配内存空间，但是没有赋真实值，为了未来的运行阶段好操作准备。这时候导出(`export`)、导入(`import`)指向的模块就指向了这个内存地址。
为了实例化模块关系图。采用**深度优先的后序遍历方式**
即，它会顺着关系图到达最底端没有任何依赖的模块，然后设置它们的导出。
最终，引擎会把模块下的所有依赖导出链接到当前模块。然后回到上一层把模块的导入链接起来。
#### 与CJS的区别
CJS是值拷贝，ESM是值引用
![](https://raw.githubusercontent.com/Hbisedm/my-blob-picGo/main/img/202207102307596.png)


### 运行阶段
> 一个模块实例结合了代码和状态。状态存储在内存中，所以实例化的过程就是把所有值写入内存的过程。

- 模块环境记录
	- 它管理着模块记录的所有变量。然后，引擎会找出多有导出在内存中的地址。模块环境记录会跟踪每个导出对应于哪个内存地址。

这些内存地址此时还没有值，只有等到运行后它们才会被填充上实际值。**有一点要注意，所有导出的函数声明都在这个阶段初始化**，这会使得后面的运行阶段变得更加简单。

为了实例化模块关系图，引擎会采用**深度优先的后序遍历方式**。  
即，它会顺着关系图到达最底端没有任何依赖的模块，然后设置它们的导出。


### 运行
最后一步是往已申请好的内存空间中填入真实值。JS 引擎通过运行顶层代码（函数外的代码）来完成填充。
除了填充值以外，运行代码也会引发一些副作用（Side Effect）。例如，一个模块可能会向服务器发起请求。

## 待删除
1.  找出从哪里下载包含模块的文件（又名模块解析）
```
// 在 html 中
<script src="main.js" type="module">

// 在 js 中
import { count } from './count.js'
```

2. 获取文件（通过从 URL 下载或从文件系统加载），并添加到模块映射中。

异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了`<script>`标签的`defer`属性。[[Script里async与defer的区别]]

3. 生成模块记录，并添加到模块映射中。



## 资料
[图说 ES Modules](https://segmentfault.com/a/1190000014318751)
