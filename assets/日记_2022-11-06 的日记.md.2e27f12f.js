import{_ as s,c as p,o as e,a}from"./app.741d02cd.js";const f=JSON.parse('{"title":"2022-11-06 的日记","description":"","frontmatter":{"title":"2022-11-06 的日记","tags":["2022-11-06 的日记"],"创建时间":"星期日, 十一月 6日 2022, 12:03:40 凌晨","修改时间":"星期日, 十一月 6日 2022, 10:16:08 晚上"},"headers":[],"relativePath":"日记/2022-11-06 的日记.md"}'),n={name:"日记/2022-11-06 的日记.md"},o=a(`<p>#日记</p><h1 id="_2022-11-06-的日记" tabindex="-1">2022-11-06 的日记 <a class="header-anchor" href="#_2022-11-06-的日记" aria-hidden="true">#</a></h1><p>[[八股文-Vue#12 - 怎么定义动态路由？怎么获取传过来的动态参数？]] [[八股文-Vue#13-如果让你从零开始写一个vue路由，说说你的思路]] [[八股文-Vue#14-能说说key的作用吗？]] [[八股文-Vue#15-说说nextTick的使用和原理？]]</p><p>vue的核心模块 reactive 的再次复习</p><p>定一个proxy对象 携带 <code>get</code> <code>set</code></p><p>get =&gt; track 收集依赖 set =&gt; trigger 触发依赖</p><p>effect的时候 会执行里面定义的函数 (定义的时候触发执行第一次)</p><p>函数里面若有响应式对象<code>reactive</code> 对应的proxy对象，会触发get=&gt; 然后触发track=&gt; 收集依赖</p><p>这个依赖 指的是 effect副作用函数的实例</p><p>实例指的是一个对象的实例，里面有个<code>fn</code>只想effect包裹的函数</p><p>依赖被收集到<code>effect.ts</code>这个模块中的weakMap的target的filed中</p><p>每次set的时候，触发trigger，执行对应的fn</p><p>依赖 和 响应式对象 是 多对多的关系</p><p>一个effect有多个响应式对象</p><p>一个响应式对象有多个effect副作用函数</p><p>响应式的目的是 自动执行定义好的代码</p><p>所以才有后面的ref，watch，computed等等</p><p>所以effect是他们可以做出相应的基础</p><p>effect 翻译 就是副作用</p><p><strong>响应式 -&gt; 改变某个值 -&gt; 执行相对应的所有副作用函数</strong></p><p>看了readonly</p><p>readonly表示只读不可set</p><p>所以set对应的trigger 直接 return就行</p><p>抽离出 是readonly 还是 reactive 的set handle 逻辑</p><p>判断 是否reactive 和 是否readonly</p><p>定义2个key，通过proxy的get函数 去拿到这2个key 判断</p><p>stop的优化，stop为清空响应式对象的dep(收集effect的set集合)</p><p>但是呢清空后，如果再次get的话，会再次收集，所以啊，需要定一个判断状态变量，在track那里进行判断。 直接不收集就行了。</p><p>shallowReadOnly的实现</p><p>第一层要readonly的特性，更深层是普通对象的特性</p><p>也就是get判断为shallow的话，不做收集依赖的操作。</p><p>ref是基本数据类型的响应式对象</p><p>那么使用es6的class进行判断</p><p>将收集依赖和触发依赖的后的操作抽离出来。供给ref和reactive去用</p><p>这里区别下ref和reactive</p><p>ref是一个类对象，里面有个dep属性</p><p>reactive的dep是在全局的weakmap</p><p>isRef 直接定一个key，判断这个值有没有key</p><p>proxyRefs 是 在template里面 ref不需要用<code>.value</code>去拿值</p><p>也是一个proxy</p><p>get的时候 返回<code>unRef(target[key])</code> 这样就没有<code>.value</code></p><p>set的时候 如果新的值不是ref的话，需要特殊处理</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki"><code><span class="line"><span style="color:#676E95;">// set 上一个值是ref，新值不是ref,需要特殊处理 </span></span>
<span class="line"><span style="color:#82AAFF;">set</span><span style="color:#A6ACCD;">(target</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> key</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> value) </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#89DDFF;">if</span><span style="color:#F07178;"> (</span><span style="color:#82AAFF;">isRef</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">target</span><span style="color:#F07178;">[</span><span style="color:#A6ACCD;">key</span><span style="color:#F07178;">]) </span><span style="color:#89DDFF;">&amp;&amp;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">!</span><span style="color:#82AAFF;">isRef</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">value</span><span style="color:#F07178;">)) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">		</span><span style="color:#89DDFF;">return</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">target</span><span style="color:#F07178;">[</span><span style="color:#A6ACCD;">key</span><span style="color:#F07178;">]</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">value</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">else</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span></span>
<span class="line"><span style="color:#F07178;">		</span><span style="color:#89DDFF;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">Reflect</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">set</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">target</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">key</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">value</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span></span>
<span class="line"><span style="color:#89DDFF;">},</span></span>
<span class="line"></span></code></pre></div><p>computed 和ref类似 也是需要个<code>.value</code></p>`,44),l=[o];function t(c,r,y,F,D,d){return e(),p("div",null,l)}const A=s(n,[["render",t]]);export{f as __pageData,A as default};
