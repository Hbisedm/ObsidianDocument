import{_ as e,c as t,o as a,a as i}from"./app.e5db1f59.js";const _=JSON.parse('{"title":"10w数据渲染的笔记","description":"","frontmatter":{"title":"10w数据渲染的笔记","tags":["10w数据渲染"],"创建时间":"星期一, 十二月 12日 2022, 2:02:46 下午","修改时间":"星期二, 十二月 13日 2022, 1:11:14 下午"},"headers":[{"level":2,"title":"for循环","slug":"for循环","link":"#for循环","children":[]},{"level":2,"title":"虚拟列表","slug":"虚拟列表","link":"#虚拟列表","children":[]},{"level":2,"title":"时间分片","slug":"时间分片","link":"#时间分片","children":[{"level":3,"title":"setTimeout","slug":"settimeout","link":"#settimeout","children":[]},{"level":3,"title":"requestAnimationFrame","slug":"requestanimationframe","link":"#requestanimationframe","children":[]}]},{"level":2,"title":"参考文章","slug":"参考文章","link":"#参考文章","children":[]}],"relativePath":"工作区/关于面试/笔试题/10w数据渲染.md"}'),r={name:"工作区/关于面试/笔试题/10w数据渲染.md"},n=i('<p>#面试题</p><h1 id="_10w数据渲染的笔记" tabindex="-1">10w数据渲染的笔记 <a class="header-anchor" href="#_10w数据渲染的笔记" aria-hidden="true">#</a></h1><blockquote><p>for循环 虚拟列表 时间分片</p></blockquote><h2 id="for循环" tabindex="-1">for循环 <a class="header-anchor" href="#for循环" aria-hidden="true">#</a></h2><p>占用性能，会有严重的卡顿现象</p><h2 id="虚拟列表" tabindex="-1">虚拟列表 <a class="header-anchor" href="#虚拟列表" aria-hidden="true">#</a></h2><p>[[虚拟列表]]</p><h2 id="时间分片" tabindex="-1">时间分片 <a class="header-anchor" href="#时间分片" aria-hidden="true">#</a></h2><p>requestAnimationFrame + fragment</p><ul><li>使用requestAnimationFrame代替setTimeout，减少了重排的次数，极大提高了性能，建议大家在渲染方面多使用requestAnimationFrame</li><li>使用Fragment可以减少appendChild的次数，极大提高性能。</li><li>Fragment只渲染包裹的元素，不会渲染Fragment元素</li></ul><h3 id="settimeout" tabindex="-1">setTimeout <a class="header-anchor" href="#settimeout" aria-hidden="true">#</a></h3><blockquote><p>使用setTimeout, 滑动太快会出现闪屏现象</p></blockquote><ul><li>FPS表示每秒更新屏幕的帧数，60FPS让人倍感舒适</li><li>setTimeout的执行时间不确定！JS的[[EventLoop]]这个机制，setTimeout的宏任务只有当主线程空闲时，才会执行，因此setTimeout的实际执行时间可能会比其设定的时间要晚一些。</li><li>刷新频率受屏幕分辨率和尺寸影响</li></ul><p><strong>在setTimeout中对dom的操作，必须要等到屏幕下次绘制时才能更新到屏幕上，如果两者步调不一致的话，就可能导致中间某一帧的操作被跨越过去了，而直接更新下一帧的元素。从而导致丢帧的现象。</strong></p><h3 id="requestanimationframe" tabindex="-1">requestAnimationFrame <a class="header-anchor" href="#requestanimationframe" aria-hidden="true">#</a></h3><p>使用requestAnimationFrame最大的优势是由系统来决定回调函数的执行时机。</p><p>如果屏幕刷新率是60Hz,那么回调函数就每16.7ms被执行一次，如果刷新率是75Hz，那么这个时间间隔就变成了1000/75=13.3ms，换句话说就是，<code>requestAnimationFrame</code>的步伐跟着系统的刷新步伐走。它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次，这样就不会引起丢帧现象。</p><h2 id="参考文章" tabindex="-1">参考文章 <a class="header-anchor" href="#参考文章" aria-hidden="true">#</a></h2><p><a href="https://juejin.cn/post/6844903938894872589" target="_blank" rel="noreferrer">10w数据渲染</a></p>',19),o=[n];function l(s,d,h,u,m,c){return a(),t("div",null,o)}const f=e(r,[["render",l]]);export{_ as __pageData,f as default};
