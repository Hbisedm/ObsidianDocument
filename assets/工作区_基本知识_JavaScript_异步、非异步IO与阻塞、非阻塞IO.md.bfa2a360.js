import{_ as e,c as i,o as l,a as o}from"./app.6426b36b.js";const u=JSON.parse('{"title":"异步、非异步IO与阻塞、非阻塞IO","description":"","frontmatter":{"title":"异步、非异步IO与阻塞、非阻塞IO","创建时间":"星期三, 七月 27日 2022, 8:58:57 晚上","修改时间":"星期一, 十一月 21日 2022, 11:34:10 中午"},"headers":[{"level":2,"title":"什么是I/O？","slug":"什么是i-o","link":"#什么是i-o","children":[{"level":3,"title":"I/O过程","slug":"i-o过程","link":"#i-o过程","children":[]}]},{"level":2,"title":"I/O模型类型","slug":"i-o模型类型","link":"#i-o模型类型","children":[{"level":3,"title":"阻塞IO","slug":"阻塞io","link":"#阻塞io","children":[]},{"level":3,"title":"非阻塞IO","slug":"非阻塞io","link":"#非阻塞io","children":[]},{"level":3,"title":"IO复用模型","slug":"io复用模型","link":"#io复用模型","children":[]},{"level":3,"title":"信号驱动IO模型","slug":"信号驱动io模型","link":"#信号驱动io模型","children":[]},{"level":3,"title":"异步IO模型","slug":"异步io模型","link":"#异步io模型","children":[]}]},{"level":2,"title":"node中的阻塞和非阻塞I/O","slug":"node中的阻塞和非阻塞i-o","link":"#node中的阻塞和非阻塞i-o","children":[]},{"level":2,"title":"异步 I/O 的本质","slug":"异步-i-o-的本质","link":"#异步-i-o-的本质","children":[]},{"level":2,"title":"nodejs中的异步 I/O 方案","slug":"nodejs中的异步-i-o-方案","link":"#nodejs中的异步-i-o-方案","children":[]}],"relativePath":"工作区/基本知识/JavaScript/异步、非异步IO与阻塞、非阻塞IO.md"}'),t={name:"工作区/基本知识/JavaScript/异步、非异步IO与阻塞、非阻塞IO.md"},a=o('<p>#异步 #io</p><h1 id="异步、非异步io与阻塞、非阻塞io" tabindex="-1">异步、非异步IO与阻塞、非阻塞IO <a class="header-anchor" href="#异步、非异步io与阻塞、非阻塞io" aria-hidden="true">#</a></h1><h2 id="什么是i-o" tabindex="-1">什么是I/O？ <a class="header-anchor" href="#什么是i-o" aria-hidden="true">#</a></h2><blockquote><p>IO有内存IO、网络IO和磁盘IO三种，通常我们说的IO指的是后两者。</p></blockquote><p>首先，我想有必要把 I/O 的概念解释一下。I/O 即Input/Output, 输入和输出的意思。在浏览器端，只有一种 I/O，那就是利用 Ajax 发送网络请求，然后读取返回的内容，这属于<code>网络I/O</code>。回到 nodejs 中，其实这种的 I/O 的场景就更加广泛了，主要分为两种:</p><ul><li>文件 I/O。比如用 fs 模块对文件进行读写操作。</li><li>网络 I/O。比如 http 模块发起网络请求。</li></ul><h3 id="i-o过程" tabindex="-1">I/O过程 <a class="header-anchor" href="#i-o过程" aria-hidden="true">#</a></h3><p><img src="https://raw.githubusercontent.com/Hbisedm/my-blob-picGo/main/img/202211211112774.png" alt=""></p><p>对于一个输入操作来说，进程IO系统调用后，内核会先看缓冲区中有没有相应的缓存数据，没有的话再到设备中读取，因为设备IO一般速度较慢，需要等待；内核缓冲区有数据则直接复制到进程空间。</p><p>所以，对于一个网络输入操作通常包括两个不同阶段：</p><ul><li>等待网络数据到达网卡→读取到内核缓冲区，数据准备好；</li><li>从内核缓冲区复制数据到进程空间。</li></ul><h2 id="i-o模型类型" tabindex="-1">I/O模型类型 <a class="header-anchor" href="#i-o模型类型" aria-hidden="true">#</a></h2><ul><li>阻塞IO</li><li>非阻塞IO</li><li>IO复用模型</li><li>信号驱动的IO模型</li><li>异步IO模型</li></ul><p>前四种都是<strong>同步</strong>IO模型，最后一个是<strong>异步</strong>IO</p><h3 id="阻塞io" tabindex="-1">阻塞IO <a class="header-anchor" href="#阻塞io" aria-hidden="true">#</a></h3><p><img src="https://raw.githubusercontent.com/Hbisedm/my-blob-picGo/main/img/202211211127225.png" alt=""></p><p>1、典型应用：阻塞socket、Java BIO；</p><p>2、特点：</p><ul><li>进程阻塞挂起不消耗CPU资源，及时响应每个操作；</li><li>实现难度低、开发应用较容易；</li><li>适用并发量小的网络应用开发；</li></ul><p>不适用并发量大的应用：因为一个请求IO会阻塞进程，所以，得为每请求分配一个处理进程（线程）以及时响应，系统开销大。</p><h3 id="非阻塞io" tabindex="-1">非阻塞IO <a class="header-anchor" href="#非阻塞io" aria-hidden="true">#</a></h3><p><img src="https://raw.githubusercontent.com/Hbisedm/my-blob-picGo/main/img/202211211127184.png" alt=""></p><p>进程发起IO系统调用后，如果内核缓冲区没有数据，需要到IO设备中读取，进程返回一个错误而不会被阻塞；进程发起IO系统调用后，如果内核缓冲区有数据，内核就会把数据返回进程。</p><p>对于上面的阻塞IO模型来说，内核数据没准备好需要进程阻塞的时候，就返回一个错误，以使得进程不被阻塞。</p><p>1、典型应用：socket是非阻塞的方式（设置为NONBLOCK）</p><p>2、特点：</p><ul><li>进程轮询（重复）调用，消耗CPU的资源；</li><li>实现难度低、开发应用相对阻塞IO模式较难；</li><li>适用并发量较小、且不需要及时响应的网络应用开发；</li></ul><h3 id="io复用模型" tabindex="-1">IO复用模型 <a class="header-anchor" href="#io复用模型" aria-hidden="true">#</a></h3><p><img src="https://raw.githubusercontent.com/Hbisedm/my-blob-picGo/main/img/202211211128209.png" alt=""></p><p>多个的进程的IO可以注册到一个复用器（select）上，然后用一个进程调用该select， select会监听所有注册进来的IO；</p><p>如果select没有监听的IO在内核缓冲区都没有可读数据，select调用进程会被阻塞；而当任一IO在内核缓冲区中有可数据时，select调用就会返回；</p><p>而后select调用进程可以自己或通知另外的进程（注册进程）来再次发起读取IO，读取内核中准备好的数据。</p><p>可以看到，多个进程注册IO后，只有另一个select调用进程被阻塞。</p><p>1、典型应用：select、poll、epoll三种方案，nginx都可以选择使用这三个方案;Java NIO;</p><p>2、特点：</p><ul><li>专一进程解决多个进程IO的阻塞问题，性能好；Reactor模式;</li><li>实现、开发应用难度较大；</li><li>适用高并发服务应用开发：一个进程（线程）响应多个请求；</li></ul><p>3、select、poll、epoll</p><ul><li>Linux中IO复用的实现方式主要有select、poll和epoll：</li><li>Select：注册IO、阻塞扫描，监听的IO最大连接数不能多于FD_SIZE；</li><li>Poll：原理和Select相似，没有数量限制，但IO数量大扫描线性性能下降；</li><li>Epoll ：事件驱动不阻塞，mmap实现内核与用户空间的消息传递，数量很大，Linux2.6后内核支持；</li></ul><h3 id="信号驱动io模型" tabindex="-1">信号驱动IO模型 <a class="header-anchor" href="#信号驱动io模型" aria-hidden="true">#</a></h3><p><img src="https://raw.githubusercontent.com/Hbisedm/my-blob-picGo/main/img/202211211133528.png" alt=""></p><p>当进程发起一个IO操作，会向内核注册一个信号处理函数，然后进程返回不阻塞；当内核数据就绪时会发送一个信号给进程，进程便在信号处理函数中调用IO读取数据。</p><p>特点：回调机制，实现、开发应用难度大</p><h3 id="异步io模型" tabindex="-1">异步IO模型 <a class="header-anchor" href="#异步io模型" aria-hidden="true">#</a></h3><p><img src="https://raw.githubusercontent.com/Hbisedm/my-blob-picGo/main/img/202211211133277.png" alt=""></p><p>当进程发起一个IO操作，进程返回（不阻塞），但也不能返回果结；内核把整个IO处理完后，会通知进程结果。如果IO操作成功则进程直接获取到数据。</p><p>1、典型应用：JAVA7 AIO、高性能<a href="https://cloud.tencent.com/product/cvm?from=10680" target="_blank" rel="noreferrer">服务器</a>应用</p><p>2、特点：</p><ul><li>不阻塞，数据一步到位；Proactor模式；</li><li>需要操作系统的底层支持，LINUX 2.5 版本内核首现，2.6 版本产品的内核标准特性；</li><li>实现、开发应用难度大；</li><li>非常适合高性能高并发应用；</li></ul><h2 id="node中的阻塞和非阻塞i-o" tabindex="-1">node中的阻塞和非阻塞I/O <a class="header-anchor" href="#node中的阻塞和非阻塞i-o" aria-hidden="true">#</a></h2><blockquote><p>探索node对于IO模型的操作</p></blockquote><p><code>阻塞</code>和<code>非阻塞</code> I/O 其实是针对操作系统内核而言的，而不是 nodejs 本身。阻塞 I/O 的特点就是一定要<strong>等到操作系统完成所有操作后才表示调用结束</strong>，而非阻塞 I/O 是调用后立马返回，不用等操作系统内核完成操作。</p><p>对前者而言，在操作系统进行 I/O 的操作的过程中，我们的应用程序其实是一直处于等待状态的，什么都做不了。那如果换成<code>非阻塞I/O</code>，调用返回后我们的 nodejs 应用程序可以完成其他的事情，而操作系统同时也在进行 I/O。这样就把等待的时间充分利用了起来，提高了执行效率，但是同时又会产生一个问题，nodejs 应用程序怎么知道操作系统已经完成了 I/O 操作呢？</p><p>为了让 nodejs 知道操作系统已经做完 I/O 操作，需要重复地去操作系统那里判断一下是否完成，这种重复判断的方式就是<code>轮询</code>。对于轮询而言，有以下这么几种方案:</p><ol><li><p>一直轮询检查I/O状态，直到 I/O 完成。这是最原始的方式，也是性能最低的，会让 CPU 一直耗用在等待上面。其实跟阻塞 I/O 的效果是一样的。</p></li><li><p>遍历文件描述符(即 文件I/O 时操作系统和 nodejs 之间的文件凭证)的方式来确定 I/O 是否完成，I/O完成则文件描述符的状态改变。但 CPU 轮询消耗还是很大。</p></li><li><p>epoll模式。即在进入轮询的时候如果I/O未完成CPU就休眠，完成之后唤醒CPU。</p></li></ol><p>总之，CPU要么重复检查I/O，要么重复检查文件描述符，要么休眠，都得不到很好的利用，我们希望的是:</p><blockquote><p>nodejs 应用程序发起 I/O 调用后可以直接去执行别的逻辑，操作系统默默地做完 I/O 之后给 nodejs 发一个完成信号，nodejs 执行回调操作。</p></blockquote><p>这是理想的情况，也是异步 I/O 的效果，那如何实现这样的效果呢？</p><h2 id="异步-i-o-的本质" tabindex="-1">异步 I/O 的本质 <a class="header-anchor" href="#异步-i-o-的本质" aria-hidden="true">#</a></h2><p>Linux 原生存在这样的一种方式，即(AIO), 但两个致命的缺陷:</p><ol><li>只有 Linux 下存在，在其他系统中没有异步 I/O 支持。</li><li>无法利用系统缓存。</li></ol><h2 id="nodejs中的异步-i-o-方案" tabindex="-1">nodejs中的异步 I/O 方案 <a class="header-anchor" href="#nodejs中的异步-i-o-方案" aria-hidden="true">#</a></h2><p>是不是没有办法了呢？在单线程的情况下确实是这样，但是如果把思路放开一点，利用多线程来考虑这个问题，就变得轻松多了。我们可以让一个进程进行计算操作，另外一些进行 I/O 调用，I/O 完成后把信号传给计算的线程，进而执行回调，这不就好了吗？没错，<strong>异步 I/O 就是使用这样的线程池来实现的</strong>。 nodejs单线程通过非阻塞异步回调进程处理多个任务，不支持多线程，但现在已经不成立了。在 Node.js 10.15.0 中，有一个名为工作线程（worker threads）的新模块可用于实现多线程。</p><p>交给操作系统</p><p>总结 :</p><ol><li><code>阻塞</code>和<code>非阻塞</code> I/O 其实是针对操作系统内核而言的。阻塞 I/O 的特点就是一定要<strong>等到操作系统完成所有操作后才表示调用结束</strong>，而非阻塞 I/O 是调用后立马返回，不用等操作系统内核完成操作。</li><li>nodejs中的异步 I/O 采用多线程的方式，由 <code>EventLoop</code>、<code>I/O 观察者</code>，<code>请求对象</code>、<code>线程池</code>四大要素相互配合，共同实现。</li></ol><p><a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" target="_blank" rel="noreferrer">进程与线程</a><a href="https://sanyuan0704.top/blogs/javascript/js-async/001.html" target="_blank" rel="noreferrer">参考链接</a><a href="https://segmentfault.com/a/1190000021462627" target="_blank" rel="noreferrer">node.js的多线程与多进程</a><a href="https://zhuanlan.zhihu.com/p/74879045" target="_blank" rel="noreferrer">理解Node.js中的&quot;多线程&quot; - 知乎</a><a href="https://cloud.tencent.com/developer/article/1684951" target="_blank" rel="noreferrer">IO模型</a></p>',66),r=[a];function n(p,d,c,s,h,I){return l(),i("div",null,r)}const g=e(t,[["render",n]]);export{u as __pageData,g as default};
