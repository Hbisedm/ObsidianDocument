import{_ as e,c as t,o as a,a as o}from"./app.e5db1f59.js";const k=JSON.parse('{"title":"Vue的key理解","description":"","frontmatter":{"title":"Vue的key理解","tags":["Vue"],"excerpt":"key的概念","创建时间":"星期三, 七月 27日 2022, 8:58:57 晚上","修改时间":"星期四, 八月 25日 2022, 10:37:46 晚上"},"headers":[{"level":2,"title":"作用(重头戏)","slug":"作用-重头戏","link":"#作用-重头戏","children":[]}],"relativePath":"工作区/框架技术/Vue/原理/Vue的key.md"}'),d={name:"工作区/框架技术/Vue/原理/Vue的key.md"},r=o('<p>#Vue #Key</p><h1 id="vue的key理解" tabindex="-1">Vue的key理解 <a class="header-anchor" href="#vue的key理解" aria-hidden="true">#</a></h1><ul><li>key是为Vue中的vnode标记的唯一id,通过这个key,我们的diff操作可以更准确、更快速</li><li>diff算法的过程中,先会进行新旧节点的首尾交叉对比,当无法匹配的时候会用新节点的key与旧节点进行比对,然后超出差异.</li></ul><h2 id="作用-重头戏" tabindex="-1">作用(重头戏) <a class="header-anchor" href="#作用-重头戏" aria-hidden="true">#</a></h2><p>我们都知道，<code>Vue</code>很大的一个特点就是双向数据绑定，数据一旦改变，那么页面就渲染新的数据呈现在页面上。</p><p>那么问题来了，对于用<code>v-for</code>渲染的<strong>列表</strong>数据来说，数据量可能一般很庞大，而且我们经常还要对这个数据进行一些增删改操作。假设我们给列表增加一条数据，整个列表都要重新渲染一遍，那不就很费事了。</p><p>而<code>key</code>的出现就是尽可能的回避这个问题，提高效率，如果我们给列表增加了一条数据，页面只渲染了这数据，那不就很完美了。</p><p><code>v-for</code>默认使用就地复用策略，列表数据修改的时候，他会根据key值去判断某个值是否修改，如果修改，则重新渲染这一项，否则复用之前的元素。</p>',8),c=[r];function i(n,s,_,u,l,p){return a(),t("div",null,c)}const f=e(d,[["render",i]]);export{k as __pageData,f as default};
