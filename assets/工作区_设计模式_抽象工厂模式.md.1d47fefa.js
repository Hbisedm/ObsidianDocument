import{_ as t,c as e,o as r,a as o}from"./app.64cc5612.js";const f=JSON.parse('{"title":"抽象工厂模式的笔记","description":"","frontmatter":{"title":"抽象工厂模式的笔记","tags":["抽象工厂模式"],"创建时间":"星期一, 九月 12日 2022, 11:00:23 晚上","修改时间":"星期一, 九月 12日 2022, 11:08:33 晚上"},"headers":[],"relativePath":"工作区/设计模式/抽象工厂模式.md"}'),a={name:"工作区/设计模式/抽象工厂模式.md"},s=o('<p>#抽象工厂模式</p><h1 id="抽象工厂模式的笔记" tabindex="-1">抽象工厂模式的笔记 <a class="header-anchor" href="#抽象工厂模式的笔记" aria-hidden="true">#</a></h1><ol><li><p><strong>抽象产品</strong> （Abstract Product） 为构成系列产品的一组不同但相关的产品声明接口。</p></li><li><p><strong>具体产品</strong> （Concrete Product） 是抽象产品的多种不同类型实现。 所有变体 （维多利亚/现代） 都必须实现相应的抽象产品 （椅子/沙发）。</p></li><li><p><strong>抽象工厂</strong> （Abstract Factory） 接口声明了一组创建各种抽象产品的方法。</p></li><li><p><strong>具体工厂</strong> （Concrete Factory） 实现抽象工厂的构建方法。 每个具体工厂都对应特定产品变体， 且仅创建此种产品变体。</p></li><li><p>尽管具体工厂会对具体产品进行初始化， 其构建方法签名必须返回相应的_抽象_产品。 这样， 使用工厂类的客户端代码就不会与工厂创建的特定产品变体耦合。 <strong>客户端</strong> （Client） 只需通过抽象接口调用工厂和产品对象， 就能与任何具体工厂/产品变体交互。</p></li><li><p>工厂生产产品</p></li><li><p>用户只看产品效果，不关注产品生产过程</p></li><li><p>用户只关注哪家工厂，以及它的周边产品。</p></li></ol>',3),_=[s];function i(n,c,l,p,d,g){return r(),e("div",null,_)}const m=t(a,[["render",i]]);export{f as __pageData,m as default};
