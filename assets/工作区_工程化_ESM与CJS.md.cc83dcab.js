import{_ as s,c as a,o as l,a as n}from"./app.6426b36b.js";const m=JSON.parse('{"title":"commonJS","description":"","frontmatter":{"title":"commonJS","tags":["工程化"],"excerpt":"模块化规范.","创建时间":"星期三, 七月 27日 2022, 8:58:57 晚上","修改时间":"星期六, 八月 13日 2022, 9:17:09 晚上"},"headers":[{"level":2,"title":"exports导出","slug":"exports导出","link":"#exports导出","children":[]},{"level":2,"title":"module.exports","slug":"module-exports","link":"#module-exports","children":[]},{"level":2,"title":"require细节","slug":"require细节","link":"#require细节","children":[]},{"level":2,"title":"模块加载顺序","slug":"模块加载顺序","link":"#模块加载顺序","children":[]},{"level":2,"title":"export有三种方式","slug":"export有三种方式","link":"#export有三种方式","children":[]},{"level":2,"title":"import的三种方式","slug":"import的三种方式","link":"#import的三种方式","children":[]},{"level":2,"title":"export与import结合","slug":"export与import结合","link":"#export与import结合","children":[{"level":3,"title":"bar.js 抛出一个函数","slug":"bar-js-抛出一个函数","link":"#bar-js-抛出一个函数","children":[]},{"level":3,"title":"foo.js导入bar.js 并抛出去 做了个中转","slug":"foo-js导入bar-js-并抛出去-做了个中转","link":"#foo-js导入bar-js-并抛出去-做了个中转","children":[]},{"level":3,"title":"main.js直接从foo中导入：","slug":"main-js直接从foo中导入","link":"#main-js直接从foo中导入","children":[]},{"level":3,"title":"甚至在foo.js中导出时，我们可以变化它的名字","slug":"甚至在foo-js中导出时-我们可以变化它的名字","link":"#甚至在foo-js中导出时-我们可以变化它的名字","children":[]}]},{"level":2,"title":"default(重要‼️)","slug":"default-重要-️","link":"#default-重要-️","children":[{"level":3,"title":"导出：","slug":"导出","link":"#导出","children":[]},{"level":3,"title":"导入","slug":"导入","link":"#导入","children":[]},{"level":3,"title":"import()方法的使用","slug":"import-方法的使用","link":"#import-方法的使用","children":[]}]},{"level":2,"title":"区别","slug":"区别","link":"#区别","children":[]}],"relativePath":"工作区/工程化/ESM与CJS.md"}'),e={name:"工作区/工程化/ESM与CJS.md"},o=n(`<p>#工程化 #ESC #CJS</p><h1 id="commonjs" tabindex="-1">commonJS <a class="header-anchor" href="#commonjs" aria-hidden="true">#</a></h1><p>node的规范</p><h2 id="exports导出" tabindex="-1">exports导出 <a class="header-anchor" href="#exports导出" aria-hidden="true">#</a></h2><p><strong>强调：exports是一个对象，我们可以在这个对象中添加很多个属性，添加的属性会导出</strong> bar.js</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">exports.name = name;</span></span>
<span class="line"><span style="color:#A6ACCD;">exports.age = age;</span></span>
<span class="line"><span style="color:#A6ACCD;">exports.sayHello = sayHello;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>main.js</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">const bar = require(&#39;./bar&#39;);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>上面这行代码意味着main中的bar变量等于exports对象；</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">main中的bar = bar中的exports</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>所以，我们可以使用使用bar这个对象</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">const bar = require(&#39;./bar&#39;);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">const name = bar.name;</span></span>
<span class="line"><span style="color:#A6ACCD;">const age = bar.age;</span></span>
<span class="line"><span style="color:#A6ACCD;">const sayHello = bar.sayHello;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(name);</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(age);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">sayHello(&#39;kobe&#39;);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>为了进一步论证，bar和exports是同一个对象：</p><ul><li>所以，bar对象是exports对象的<strong>浅拷贝</strong>；</li><li>浅拷贝的本质就是一种引用的赋值而已；</li></ul><h2 id="module-exports" tabindex="-1">module.exports <a class="header-anchor" href="#module-exports" aria-hidden="true">#</a></h2><p>我们追根溯源，通过维基百科中对CommonJS规范的解析：</p><ul><li>CommonJS中是没有module.exports的概念的；</li><li>但是为了实现模块的导出，Node中使用的是Module的类，每一个模块都是Module的一个实例，也就是module；</li><li>所以在Node中真正用于导出的其实根本不是exports，而是module.exports；</li><li>因为module才是导出的真正实现者；</li></ul><p>但是，为什么exports也可以导出呢？</p><ul><li>这是因为module对象的exports属性是exports对象的一个引用；</li><li>也就是说 module.exports = exports = main中的bar；</li></ul><p><strong>注意：真正导出的模块内容的核心其实是module.exports，只是为了实现CommonJS的规范，刚好module.exports对exports对象有一个引用而已；</strong></p><p><img src="https://raw.githubusercontent.com/Hbisedm/my-blob-picGo/main/img/202205292127882.png" alt="img"></p><ul><li>结论：和exports对象没有任何关系了，exports你随便玩自己的吧；</li><li>module.exports我现在导出一个自己的对象，不带着你玩了；</li><li>新的对象取代了exports对象的导出，那么就意味着require导入的对象是新的对象；</li></ul><p><img src="https://raw.githubusercontent.com/Hbisedm/my-blob-picGo/main/img/202205292128757.png" alt="img"></p><h2 id="require细节" tabindex="-1">require细节 <a class="header-anchor" href="#require细节" aria-hidden="true">#</a></h2><p>我们现在已经知道，require是一个函数，可以帮助我们引入一个文件（模块）中导入的对象。</p><p>那么，require的查找规则是怎么样的呢？ <a href="https://nodejs.org/dist/latest-v14.x/docs/api/modules.html#modules_all_together" target="_blank" rel="noreferrer">node官方文档require</a></p><h2 id="模块加载顺序" tabindex="-1">模块加载顺序 <a class="header-anchor" href="#模块加载顺序" aria-hidden="true">#</a></h2><p>这里我们研究一下模块的加载顺序问题。</p><ul><li>结论一：模块在被第一次引入时，模块中的js代码会被运行一次</li><li>结论二：模块被多次引入时，会缓存，最终只加载（运行）一次</li></ul><blockquote><p>为什么只会加载运行一次呢？</p><ul><li>这是因为每个模块对象module都有一个属性：loaded。</li><li>为false表示还没有加载，为true表示已经加载；</li></ul></blockquote><ul><li>结论三：如果有循环引入，那么加载顺序是什么？</li></ul><blockquote><p>如果出现下面模块的引用关系，那么加载顺序是什么呢？</p><ul><li>这个其实是一种数据结构：图结构；</li><li>图结构在遍历的过程中，有深度优先搜索（DFS, depth first search）和广度优先搜索（BFS, breadth first search）；</li><li>Node采用的是深度优先算法：main -&gt; aaa -&gt; ccc -&gt; ddd -&gt; eee -&gt;bbb</li></ul></blockquote><p><img src="https://raw.githubusercontent.com/Hbisedm/my-blob-picGo/main/img/202205291346848.png" alt="55f36dbec645630eb35a864be36c0ff6.png"></p><h1 id="es-module" tabindex="-1">ES Module <a class="header-anchor" href="#es-module" aria-hidden="true">#</a></h1><p>语言的规范</p><h2 id="export有三种方式" tabindex="-1">export有三种方式 <a class="header-anchor" href="#export有三种方式" aria-hidden="true">#</a></h2><ol><li>定义变量时，抛出</li></ol><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">export const name = &#39;Sam&#39; </span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><ol><li>使用{ }抛出定义的变量、函数</li></ol><ul><li>注意：这里的 {}里面不是ES6的对象字面量的增强写法，{}也不是表示一个对象的；</li><li>所以： export {name: name}，是错误的写法；</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">const name = &#39;Sam&#39; </span></span>
<span class="line"><span style="color:#A6ACCD;">export {</span></span>
<span class="line"><span style="color:#A6ACCD;">    name</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><ol><li>抛出时，可以给个别名</li></ol><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">const name = &#39;Sam&#39; </span></span>
<span class="line"><span style="color:#A6ACCD;">export {</span></span>
<span class="line"><span style="color:#A6ACCD;">    name as AModuleName</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h2 id="import的三种方式" tabindex="-1">import的三种方式 <a class="header-anchor" href="#import的三种方式" aria-hidden="true">#</a></h2><ol><li>import { 标识符列表 } from ‘module’</li></ol><ul><li>注意：这里的{}也不是一个对象，里面只是存放导入的标识符列表内容；</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">import {name} from &#39;./user_module.js&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><ol><li>导入时可以给别名</li></ol><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">import {name as username} from &#39;./user_module.js&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><ol><li>将标识符里面所有的功能放到一个模块功能对象内</li></ol><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">import * as foo from &#39;./user_module.js&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(foo.name)</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h2 id="export与import结合" tabindex="-1">export与import结合 <a class="header-anchor" href="#export与import结合" aria-hidden="true">#</a></h2><p>如果从一个模块中导入的内容，我们希望再直接导出出去，这个时候可以直接使用export来导出。</p><h3 id="bar-js-抛出一个函数" tabindex="-1">bar.js 抛出一个函数 <a class="header-anchor" href="#bar-js-抛出一个函数" aria-hidden="true">#</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">export const func = function(a, b) {</span></span>
<span class="line"><span style="color:#A6ACCD;">    return a + b</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h3 id="foo-js导入bar-js-并抛出去-做了个中转" tabindex="-1">foo.js导入bar.js 并抛出去 做了个中转 <a class="header-anchor" href="#foo-js导入bar-js-并抛出去-做了个中转" aria-hidden="true">#</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">export {func} from &#39;./bar.js&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h3 id="main-js直接从foo中导入" tabindex="-1">main.js直接从foo中导入： <a class="header-anchor" href="#main-js直接从foo中导入" aria-hidden="true">#</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">import {func} from &#39;./module/foo.js&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">func(1, 2)</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h3 id="甚至在foo-js中导出时-我们可以变化它的名字" tabindex="-1">甚至在foo.js中导出时，我们可以变化它的名字 <a class="header-anchor" href="#甚至在foo-js中导出时-我们可以变化它的名字" aria-hidden="true">#</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">export {func as fooFunc} from &#39;./bar.js&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><ul><li>为什么要这样做呢？ <ul><li>在开发和封装一个功能库时，通常我们希望将暴露的所有接口放到一个文件中；</li><li>这样方便指定统一的接口规范，也方便阅读；</li><li>这个时候，我们就可以使用export和import结合使用 ；</li></ul></li></ul><h2 id="default-重要-️" tabindex="-1">default(重要‼️) <a class="header-anchor" href="#default-重要-️" aria-hidden="true">#</a></h2><p>前面我们学习的导出功能都是有名字的导出（named exports）：</p><ul><li>在导出export时指定了名字；</li><li>在导入import时需要知道具体的名字； 还有一种导出叫做默认导出（default export）</li><li>默认导出export时可以不需要指定名字；</li><li>在导入时不需要使用 {}，并且可以自己来指定名字；</li><li>它也方便我们和现有的CommonJS等规范相互操作；</li></ul><h3 id="导出" tabindex="-1">导出： <a class="header-anchor" href="#导出" aria-hidden="true">#</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">export default function sub(num1, num2) {</span></span>
<span class="line"><span style="color:#A6ACCD;">  return num1 - num2;</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h3 id="导入" tabindex="-1">导入 <a class="header-anchor" href="#导入" aria-hidden="true">#</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">import a from &#39;./module/foo.js&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">a(1, 2)</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p><strong>注意：在一个模块中，只能有一个默认导出（default export）；</strong></p><h3 id="import-方法的使用" tabindex="-1">import()方法的使用 <a class="header-anchor" href="#import-方法的使用" aria-hidden="true">#</a></h3><p>对于动态加载模块的情况下</p><blockquote><p>错误使用 <img src="https://raw.githubusercontent.com/Hbisedm/my-blob-picGo/main/img/202205291346856.png" alt="e7567502036105c87d19f0590ceb7cdc.png"></p></blockquote><blockquote><p>正确使用</p></blockquote><p>aaa.js</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">export function aaa() {</span></span>
<span class="line"><span style="color:#A6ACCD;">  console.log(&quot;aaa被打印&quot;);</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>bbb.js</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">export function bbb() {</span></span>
<span class="line"><span style="color:#A6ACCD;">  console.log(&quot;bbb被执行&quot;);</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>main.js</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">let flag = true;</span></span>
<span class="line"><span style="color:#A6ACCD;">if (flag) {</span></span>
<span class="line"><span style="color:#A6ACCD;">  import(&#39;./modules/aaa.js&#39;).then(aaa =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">    aaa.aaa();</span></span>
<span class="line"><span style="color:#A6ACCD;">  })</span></span>
<span class="line"><span style="color:#A6ACCD;">} else {</span></span>
<span class="line"><span style="color:#A6ACCD;">  import(&#39;./modules/bbb.js&#39;).then(bbb =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">    bbb.bbb();</span></span>
<span class="line"><span style="color:#A6ACCD;">  })</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h2 id="区别" tabindex="-1">区别 <a class="header-anchor" href="#区别" aria-hidden="true">#</a></h2><ol><li>CJS加载文件的过程是在运行时加载的，并且是同步的。</li><li>ESM加载文件的过程是编译（解析）时加载的，是异步的。</li><li>CJS 中exports和module.exports同时使用，只会拿module.exports的东西，而ESM的export和export default同时使用都可以拿到</li><li>CJS是node的规范；ESM是语言层面的规范</li><li>ESM可在编译期进行Tree Shaking，减少js体积。</li><li>cjs 模块输出的是一个值的拷贝，esm 输出的是值的引用</li><li>cjs 模块是运行时加载，esm 是编译时加载</li></ol>`,82),p=[o];function t(i,r,c,d,u,C){return l(),a("div",null,p)}const A=s(e,[["render",t]]);export{m as __pageData,A as default};
