import{_ as s,c as a,o as e,a as n}from"./app.e5db1f59.js";const y=JSON.parse('{"title":"前端性能优化的笔记","description":"","frontmatter":{"title":"前端性能优化的笔记","tags":["前端性能优化"],"创建时间":"星期二, 十月 25日 2022, 11:25:54 晚上","修改时间":"星期三, 十二月 14日 2022, 8:52:44 晚上"},"headers":[{"level":2,"title":"开篇","slug":"开篇","link":"#开篇","children":[]},{"level":2,"title":"http优化","slug":"http优化","link":"#http优化","children":[]},{"level":2,"title":"Webpack","slug":"webpack","link":"#webpack","children":[]},{"level":2,"title":"图片优化","slug":"图片优化","link":"#图片优化","children":[]},{"level":2,"title":"缓存","slug":"缓存","link":"#缓存","children":[{"level":3,"title":"HTTP缓存","slug":"http缓存","link":"#http缓存","children":[]},{"level":3,"title":"强缓存的特征","slug":"强缓存的特征","link":"#强缓存的特征","children":[]},{"level":3,"title":"强缓存的实现：从 Expires 到 Cache-control","slug":"强缓存的实现-从-expires-到-cache-control","link":"#强缓存的实现-从-expires-到-cache-control","children":[]},{"level":3,"title":"Cache-Control 应用分析","slug":"cache-control-应用分析","link":"#cache-control-应用分析","children":[]},{"level":3,"title":"no-store与no-cache","slug":"no-store与no-cache","link":"#no-store与no-cache","children":[]},{"level":3,"title":"协商缓存","slug":"协商缓存","link":"#协商缓存","children":[]},{"level":3,"title":"协商缓存的实现：从 Last-Modified 到 Etag","slug":"协商缓存的实现-从-last-modified-到-etag","link":"#协商缓存的实现-从-last-modified-到-etag","children":[]},{"level":3,"title":"小结","slug":"小结","link":"#小结","children":[]},{"level":3,"title":"MemoryCache","slug":"memorycache","link":"#memorycache","children":[]},{"level":3,"title":"Service Worker Cache","slug":"service-worker-cache","link":"#service-worker-cache","children":[]},{"level":3,"title":"Push Cache","slug":"push-cache","link":"#push-cache","children":[]}]},{"level":2,"title":"本地存储","slug":"本地存储","link":"#本地存储","children":[{"level":3,"title":"Cookie","slug":"cookie","link":"#cookie","children":[]},{"level":3,"title":"向前一步：Web Storage","slug":"向前一步-web-storage","link":"#向前一步-web-storage","children":[]},{"level":3,"title":"Local Storage","slug":"local-storage","link":"#local-storage","children":[]},{"level":3,"title":"Session Storage","slug":"session-storage","link":"#session-storage","children":[]},{"level":3,"title":"终极形态：IndexedDB","slug":"终极形态-indexeddb","link":"#终极形态-indexeddb","children":[]}]},{"level":2,"title":"CDN的缓存与回源机制解析","slug":"cdn的缓存与回源机制解析","link":"#cdn的缓存与回源机制解析","children":[{"level":3,"title":"为什么要用 CDN","slug":"为什么要用-cdn","link":"#为什么要用-cdn","children":[]},{"level":3,"title":"CDN的核心功能特写","slug":"cdn的核心功能特写","link":"#cdn的核心功能特写","children":[]},{"level":3,"title":"CDN 与前端性能优化","slug":"cdn-与前端性能优化","link":"#cdn-与前端性能优化","children":[]},{"level":3,"title":"CDN 的实际应用","slug":"cdn-的实际应用","link":"#cdn-的实际应用","children":[]},{"level":3,"title":"CDN 优化细节","slug":"cdn-优化细节","link":"#cdn-优化细节","children":[]}]},{"level":2,"title":"服务端渲染的探索与实践","slug":"服务端渲染的探索与实践","link":"#服务端渲染的探索与实践","children":[{"level":3,"title":"服务端渲染","slug":"服务端渲染","link":"#服务端渲染","children":[]},{"level":3,"title":"服务端渲染解决了什么性能问题","slug":"服务端渲染解决了什么性能问题","link":"#服务端渲染解决了什么性能问题","children":[]},{"level":3,"title":"服务端渲染的应用场景","slug":"服务端渲染的应用场景","link":"#服务端渲染的应用场景","children":[]}]},{"level":2,"title":"浏览器的运行机制","slug":"浏览器的运行机制","link":"#浏览器的运行机制","children":[{"level":3,"title":"解析过程","slug":"解析过程","link":"#解析过程","children":[]}]}],"relativePath":"工作区/性能调优/前端性能优化.md"}'),o={name:"工作区/性能调优/前端性能优化.md"},l=n(`<p>#性能优化</p><h1 id="前端性能优化的笔记" tabindex="-1">前端性能优化的笔记 <a class="header-anchor" href="#前端性能优化的笔记" aria-hidden="true">#</a></h1><blockquote><p>内容来自<a href="https://juejin.cn/book/6844733750048210957/section/6844733750031417352" target="_blank" rel="noreferrer">掘金小册</a></p></blockquote><h2 id="开篇" tabindex="-1">开篇 <a class="header-anchor" href="#开篇" aria-hidden="true">#</a></h2><p>它是 20% 的理论，加上至少 80% 的实践，甚至很多理论本身也都是我们在具体的业务场景中实践出来的。</p><blockquote><p>从输入 URL 到页面加载完成，发生了什么？</p></blockquote><p>简单分为：</p><ol><li>DNS 解析</li><li>TCP 连接</li><li>HTTP 请求抛出</li><li>服务端处理请求，HTTP 响应返回</li><li>浏览器拿到响应数据，解析响应内容，把解析的结果展示给用户</li></ol><blockquote><p>具体来说，DNS 解析花时间，能不能尽量减少解析次数或者把解析前置？能——浏览器 DNS 缓存和 DNS prefetch。TCP 每次的三次握手都急死人，有没有解决方案？有——长连接、预连接、接入 SPDY 协议。如果说这两个过程的优化往往需要我们和团队的服务端工程师协作完成，前端单方面可以做的努力有限，那么 HTTP 请求呢？——在减少请求次数和减小请求体积方面，我们应该是专家！再者，服务器越远，一次请求就越慢，那部署时就把静态资源放在离我们更近的 CDN 上是不是就能更快一些？ 以上提到的都是网络层面的性能优化。再往下走就是浏览器端的性能优化——这部分涉及资源加载优化、服务端渲染、浏览器缓存机制的利用、DOM 树的构建、网页排版和渲染过程、回流与重绘的考量、DOM 操作的合理规避等等——<strong>这正是前端工程师可以真正一展拳脚的地方</strong>。学习这些知识，不仅可以帮助我们从根本上提升页面性能，更能够大大加深个人对浏览器底层原理、运行机制的理解，一举两得！</p></blockquote><p>前三点是网络层面的性能优化，后两点为浏览器端的性能优化。</p><p>总的来说，我们将从<strong>网络层面</strong>和<strong>渲染层面</strong>两个大的维度来逐个点亮前端性能优化的技能树。</p><blockquote><p>在网络层面，我们需要学习一些必需的理论基础作为前置知识。这部分的学习或许不需要大家写特别多的代码，但需要大家对每一个知识点理解透彻，进而应用到自己日常优化的决策中去。网络层面结束后，由本地存储开始，我们会渐渐过渡到浏览器这一端的优化，大家喜闻乐见的“真代码”就会相应地多起来。</p></blockquote><h2 id="http优化" tabindex="-1">http优化 <a class="header-anchor" href="#http优化" aria-hidden="true">#</a></h2><ul><li>减少请求次数</li><li>减少单次请求所花费的时间</li></ul><h2 id="webpack" tabindex="-1">Webpack <a class="header-anchor" href="#webpack" aria-hidden="true">#</a></h2><ol><li>不要让 loader 做太多事情——以 babel-loader 为例</li><li>happypack——将loader由单线程转多线程</li><li>通过Tree-Shaking摇树删除</li><li>插件按需加载</li><li>开启gzip</li></ol><blockquote><p>gizp原理，是在一个文本文件中找出一些重复出现的字符串、临时替换它们，从而使整个文件变小。文件 中代码的重复率越高，那么压缩的效率就越高,收益也就越大。</p></blockquote><h2 id="图片优化" tabindex="-1">图片优化 <a class="header-anchor" href="#图片优化" aria-hidden="true">#</a></h2><blockquote><p>先了解图片种类</p></blockquote><table><thead><tr><th>类型</th><th>jpeg/jpg</th><th>png</th><th>svg</th><th>base64</th><th>雪碧图</th><th>webp</th></tr></thead><tbody><tr><td>特点</td><td>有损压缩、体积小、加载快、不支持透明</td><td>无损压缩、质量高、体积大、支持透明</td><td>文本文件、体积小、不失真、兼容性好</td><td>文本文件、依赖编码、小图标解决方案</td><td></td><td>年轻的全能选手</td></tr><tr><td>场景</td><td>banner图、背景图、轮播图</td><td>Logo</td><td>Logo</td><td>Logo</td><td>切图</td><td></td></tr></tbody></table><p>webp碰到兼容性问题</p><p>还有另一个维护性更强、更加灵活的方案——把判断工作交给后端，由服务器根据 HTTP 请求头部的 Accept 字段来决定返回什么格式的图片。<strong>当 Accept 字段包含 image/webp</strong> 时，就返回 WebP 格式的图片，否则返回原图。这种做法的好处是，当浏览器对 WebP 格式图片的兼容支持发生改变时，我们也不用再去更新自己的兼容判定代码，只需要服务端像往常一样对 Accept 字段进行检查即可。</p><h2 id="缓存" tabindex="-1">缓存 <a class="header-anchor" href="#缓存" aria-hidden="true">#</a></h2><p>缓存可以减少网络 IO 消耗，提高访问速度。浏览器缓存是一种操作简单、效果显著的前端性能优化手段。</p><blockquote><p>通过网络获取内容既速度缓慢又开销巨大。较大的响应需要在客户端与服务器之间进行多次往返通信，这会延迟浏览器获得和处理内容的时间，还会增加访问者的流量费用。因此，缓存并重复利用之前获取的资源的能力成为性能优化的一个关键方面。</p></blockquote><p>很多时候，大家倾向于将浏览器缓存简单地理解为“HTTP 缓存”。但事实上，浏览器缓存机制有四个方面，它们按照获取资源时请求的优先级依次排列如下：</p><p>Memory Cache Service Worker Cache HTTP Cache Push Cache</p><h3 id="http缓存" tabindex="-1">HTTP缓存 <a class="header-anchor" href="#http缓存" aria-hidden="true">#</a></h3><p>HTTP 缓存是我们日常开发中最为熟悉的一种缓存机制。它又分为<strong>强缓存</strong>和<strong>协商缓存</strong>。优先级较高的是强缓存，在命中强缓存失败的情况下，才会走协商缓存。</p><h3 id="强缓存的特征" tabindex="-1">强缓存的特征 <a class="header-anchor" href="#强缓存的特征" aria-hidden="true">#</a></h3><p>强缓存是利用 http 头中的 Expires 和 Cache-Control 两个字段来控制的。强缓存中，当请求再次发出时，浏览器会根据其中的 expires 和 cache-control 判断目标资源是否“命中”强缓存，若命中则直接从缓存中获取资源，<strong>不会再与服务端发生通信。</strong></p><h3 id="强缓存的实现-从-expires-到-cache-control" tabindex="-1">强缓存的实现：从 Expires 到 Cache-control <a class="header-anchor" href="#强缓存的实现-从-expires-到-cache-control" aria-hidden="true">#</a></h3><p>实现强缓存，过去我们一直用 <code>expires</code>。 当服务器返回响应时，在 Response Headers 中将过期时间写入 expires 字段。像这样：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki"><code><span class="line"><span style="color:#FFCB6B;">expires</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> Wed</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">11</span><span style="color:#A6ACCD;"> Sep </span><span style="color:#F78C6C;">2019</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">16</span><span style="color:#A6ACCD;">:</span><span style="color:#F78C6C;">12</span><span style="color:#A6ACCD;">:</span><span style="color:#F78C6C;">18</span><span style="color:#A6ACCD;"> GMT</span></span>
<span class="line"></span></code></pre></div><p>可以看到，expires 是一个时间戳，接下来如果我们试图再次向服务器请求资源，浏览器就会先对比本地时间和 expires 的时间戳，如果本地时间小于 expires 设定的过期时间，那么就直接去缓存中取这个资源。由于时间戳是服务器来定义的，而本地时间的取值却来自客户端，因此 expires 的工作机制对客户端时间与服务器时间之间的一致性提出了极高的要求，若服务器与客户端存在时差，将带来意料之外的结果。</p><p>expires 允许我们通过<strong>绝对的时间戳</strong>来控制缓存过期时间，相应地，<code>Cache-Control</code> 中的<code>max-age</code> 字段也允许我们通过设定<strong>相对的时间长度</strong>来达到同样的目的。在 HTTP1.1 标准试图将缓存相关配置收敛进 <code>Cache-Control</code> 这样的大背景下， <code>max-age</code>可以视作是对 expires 能力的补位/替换。在当下的前端实践里，我们普遍会倾向于使用<code>max-age</code>。但如果你的应用对<strong>向下兼容</strong>有强诉求，那么 expires 仍然是不可缺少的。</p><p>现在我们给 Cache-Control 字段一个特写：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">cache</span><span style="color:#89DDFF;">-</span><span style="color:#FFCB6B;">control</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> max</span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;">age</span><span style="color:#89DDFF;">=</span><span style="color:#F78C6C;">31536000</span></span>
<span class="line"></span></code></pre></div><p>如大家所见，在 Cache-Control 中，我们<strong>通过 max-age 来控制资源的有效期</strong>。max-age 不是一个时间戳，而是一个<strong>时间长度</strong>。在本例中，max-age 是 31536000 秒，它意味着该资源在 31536000 秒以内都是有效的。</p><p>注意，max-age 是一个相对时间，这就意味着它有能力规避掉 expires 可能会带来的时差问题：max-age 机制下，<strong>资源的过期判定不再受服务器时间戳的限制</strong>。<strong>客户端会记录请求到资源的时间点，以此作为相对时间的起点</strong>，从而确保参与计算的两个时间节点（起始时间和当前时间）都来源于客户端，由此便能够实现更加精准的判断。</p><p>Cache-Control 的 <strong>max-age</strong> 配置项相对于 expires 的<strong>优先级更高</strong>。当 Cache-Control 与 expires 同时出现时，我们以 Cache-Control 为准。</p><h3 id="cache-control-应用分析" tabindex="-1">Cache-Control 应用分析 <a class="header-anchor" href="#cache-control-应用分析" aria-hidden="true">#</a></h3><p>Cache-Control 的神通，可不止于这一个小小的 max-age。如下的用法也非常常见：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">cache</span><span style="color:#89DDFF;">-</span><span style="color:#FFCB6B;">control</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> max</span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;">age</span><span style="color:#89DDFF;">=</span><span style="color:#F78C6C;">3600</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> s</span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;">maxage</span><span style="color:#89DDFF;">=</span><span style="color:#F78C6C;">31536000</span></span>
<span class="line"></span></code></pre></div><p><strong>s-maxage 优先级高于 max-age，两者同时出现时，优先考虑 s-maxage。如果 s-maxage 未过期，则向代理服务器请求其缓存内容。</strong></p><p>s-maxage 就是用于表示 cache 服务器上（比如 cache CDN）的缓存的有效时间的，并只对 public 缓存有效。</p><blockquote><p>此处应注意这样一个细节：s-maxage仅在代理服务器中生效，客户端中我们只考虑max-age。</p></blockquote><h4 id="public-与-private" tabindex="-1">Public 与 Private <a class="header-anchor" href="#public-与-private" aria-hidden="true">#</a></h4><p>public 与 private 是针对资源是否能够被代理服务缓存而存在的一组对立概念。</p><p>如果我们为资源设置了 public，那么它既可以被浏览器缓存，也可以被代理服务器缓存；如果我们设置了 private，则该资源只能被浏览器缓存。private 为<strong>默认值</strong>。但多数情况下，public 并不需要我们手动设置，比如有很多线上网站的 cache-control 是这样的：</p><p>设置了 s-maxage，没设置 public，那么 CDN 还可以缓存这个资源吗？答案是肯定的。因为明确的缓存信息（例如“max-age”）已表示响应是可以缓存的。</p><h3 id="no-store与no-cache" tabindex="-1">no-store与no-cache <a class="header-anchor" href="#no-store与no-cache" aria-hidden="true">#</a></h3><p>no-cache 绕开了浏览器：我们为资源设置了 no-cache 后，每一次发起请求都不会再去询问浏览器的缓存情况，而是直接向服务端去确认该资源是否过期（即走我们下文即将讲解的协商缓存的路线）。</p><p>no-store 比较绝情，顾名思义就是不使用任何缓存策略。在 no-cache 的基础上，它连服务端的缓存确认也绕开了，只允许你直接向服务端发送请求、并下载完整的响应。</p><h3 id="协商缓存" tabindex="-1">协商缓存 <a class="header-anchor" href="#协商缓存" aria-hidden="true">#</a></h3><blockquote><p>浏览器与服务器合作之下的缓存策略</p></blockquote><p>协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求、下载完整的响应，还是从本地获取缓存的资源。</p><p>如果服务端提示缓存资源未改动（Not Modified），资源会被<strong>重定向</strong>到浏览器缓存，<strong>这种情况下网络请求对应的状态码是 304</strong>。</p><h3 id="协商缓存的实现-从-last-modified-到-etag" tabindex="-1">协商缓存的实现：从 Last-Modified 到 Etag <a class="header-anchor" href="#协商缓存的实现-从-last-modified-到-etag" aria-hidden="true">#</a></h3><p>Last-Modified 是一个时间戳，如果我们启用了协商缓存，它会在首次请求时随着 Response Headers 返回：</p><div class="language-yaml"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki"><code><span class="line"><span style="color:#F07178;">Last-Modified</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">Fri, 27 Oct 2017 06:35:57 GMT</span></span>
<span class="line"></span></code></pre></div><p>随后我们每次请求时，会带上一个叫 If-Modified-Since 的时间戳字段，它的值正是上一次 response 返回给它的 last-modified 值：</p><div class="language-yaml"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki"><code><span class="line"><span style="color:#F07178;">If-Modified-Since</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">Fri, 27 Oct 2017 06:35:57 GMT</span></span>
<span class="line"></span></code></pre></div><p>服务器接收到这个时间戳后，<strong>会比对该时间戳和资源在服务器上的最后修改时间是否一致</strong>，从而判断资源是否发生了变化。<strong>如果发生了变化，就会返回一个完整的响应内容，并在 Response Headers 中添加新的 Last-Modified 值</strong>；否则，返回 304 响应，Response Headers 不会再添加 Last-Modified 字段。</p><p>使用 Last-Modified 存在一些弊端，这其中最常见的就是这样两个场景：</p><p>我们编辑了文件，但文件的内容没有改变。服务端并不清楚我们是否真正改变了文件，它仍然通过最后编辑时间进行判断。因此这个资源在再次被请求时，会被当做新资源，进而引发一次完整的响应——不该重新请求的时候，也会重新请求。</p><p>当我们修改文件的速度过快时（比如花了 100ms 完成了改动），由于 If-Modified-Since 只能检查到以秒为最小计量单位的时间差，所以它是感知不到这个改动的——该重新请求的时候，反而没有重新请求了。</p><p><strong>这两个场景其实指向了同一个 bug——服务器并没有正确感知文件的变化</strong>。为了解决这样的问题，Etag 作为 Last-Modified 的补充出现了。</p><p><strong>Etag 是由服务器为每个资源生成的唯一的标识字符串，这个标识字符串是基于文件内容编码的，只要文件内容不同，它们对应的 Etag 就是不同的，反之亦然。因此 Etag 能够精准地感知文件的变化。</strong></p><p>Etag 和 Last-Modified 类似，当首次请求时，我们会在响应头里获取到一个最初的标识符字符串</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki"><code><span class="line"><span style="color:#FFCB6B;">ETag</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> W</span><span style="color:#89DDFF;">/</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">2a3b-1602480f459</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"></span></code></pre></div><p>那么下一次请求时，请求头里就会带上一个值相同的、名为 if-None-Match 的字符串供服务端比对了</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">If</span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;">None</span><span style="color:#89DDFF;">-</span><span style="color:#FFCB6B;">Match</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> W</span><span style="color:#89DDFF;">/</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">2a3b-1602480f459</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"></span></code></pre></div><p>Etag 的生成过程需要服务器额外付出开销，会影响服务端的性能，这是它的弊端。因此启用 Etag 需要我们审时度势。正如我们刚刚所提到的——Etag 并不能替代 Last-Modified，它只能作为 Last-Modified 的补充和强化存在。 Etag 在感知文件变化上比 Last-Modified 更加准确，优先级也更高。当 Etag 和 Last-Modified 同时存在时，以 Etag 为准。</p><h3 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-hidden="true">#</a></h3><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/20/165f701820fafcf8~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="cache"></p><p>当我们的资源内容不可复用时，直接为 Cache-Control 设置 no-store，拒绝一切形式的缓存；否则考虑是否每次都需要向服务器进行缓存有效确认，如果需要，那么设 Cache-Control 的值为 no-cache；否则考虑该资源是否可以被代理服务器缓存，根据其结果决定是设置为 private 还是 public；然后考虑该资源的过期时间，设置对应的 max-age 和 s-maxage 值；最后，配置协商缓存需要用到的 Etag、Last-Modified 等参数。</p><h3 id="memorycache" tabindex="-1">MemoryCache <a class="header-anchor" href="#memorycache" aria-hidden="true">#</a></h3><p>MemoryCache，是指存在内存中的缓存。从优先级上来说，它是浏览器最先尝试去命中的一种缓存。从效率上来说，它是响应速度最快的一种缓存。</p><p>内存缓存是快的，也是“短命”的。它和渲染进程“生死相依”，当进程结束后，也就是 tab 关闭以后，内存里的数据也将不复存在。</p><p>资源存不存内存，浏览器秉承的是“节约原则”。我们发现，Base64 格式的图片，几乎永远可以被塞进 memory cache，这可以视作浏览器为节省渲染开销的“自保行为”；此外，体积不大的 JS、CSS 文件，也有较大地被写入内存的几率——相比之下，较大的 JS、CSS 文件就没有这个待遇了，内存资源是有限的，它们往往被直接甩进磁盘。</p><h3 id="service-worker-cache" tabindex="-1">Service Worker Cache <a class="header-anchor" href="#service-worker-cache" aria-hidden="true">#</a></h3><p>Service Worker 是一种独立于主线程之外的 Javascript 线程。它脱离于浏览器窗体，因此无法直接访问 DOM。这样独立的个性使得 Service Worker 的“个人行为”无法干扰页面的性能，这个“幕后工作者”可以帮我们实现离线缓存、消息推送和网络代理等功能。我们借助 Service worker 实现的离线缓存就称为 Service Worker Cache。</p><p>Service Worker 的生命周期包括 install、active、working 三个阶段。一旦 Service Worker 被 install，它将始终存在，只会在 active 与 working 之间切换，除非我们主动终止它。这是它可以用来实现离线存储的重要先决条件。</p><blockquote><p>PS：大家注意 Server Worker 对协议是有要求的，必须以 https 协议为前提。</p></blockquote><h3 id="push-cache" tabindex="-1">Push Cache <a class="header-anchor" href="#push-cache" aria-hidden="true">#</a></h3><ul><li>Push Cache 是缓存的最后一道防线。浏览器只有在 Memory Cache、HTTP Cache 和 Service Worker Cache 均未命中的情况下才会去询问 Push Cache。</li><li>Push Cache 是一种存在于会话阶段的缓存，当 session 终止时，缓存也随之释放。</li><li>不同的页面只要共享了同一个 HTTP2 连接，那么它们就可以共享同一个 Push Cache。</li></ul><h2 id="本地存储" tabindex="-1">本地存储 <a class="header-anchor" href="#本地存储" aria-hidden="true">#</a></h2><h3 id="cookie" tabindex="-1">Cookie <a class="header-anchor" href="#cookie" aria-hidden="true">#</a></h3><p><strong>Cookie 的本职工作并非本地存储，而是“维持状态”。</strong></p><p>在 Web 开发的早期，人们亟需解决的一个问题就是状态管理的问题：<strong>HTTP 协议是一个无状态协议</strong>，服务器接收客户端的请求，返回一个响应，故事到此就结束了，服务器并没有记录下关于客户端的任何信息。那么下次请求的时候，如何让服务器知道“我是我”呢？</p><p>在这样的背景下，Cookie 应运而生。</p><p>Cookie 说白了就是一个存储在浏览器里的一个小小的文本文件，它附着在 HTTP 请求上，在浏览器和服务器之间“飞来飞去”。<strong>它可以携带用户信息</strong>，当服务器检查 Cookie 的时候，<strong>便可以获取到客户端的状态</strong>。</p><ul><li>Cookie的性能劣势</li><li>Cookie 不够大</li></ul><p>大家知道，Cookie 是有体积上限的，它最大只能有 4KB。当 Cookie 超过 4KB 时，它将面临被裁切的命运。这样看来，Cookie 只能用来存取少量的信息。</p><p>过量的 Cookie 会带来巨大的性能浪费</p><p><strong>Cookie 是紧跟域名的</strong>。我们通过响应头里的 Set-Cookie 指定要存储的 Cookie 值。默认情况下，domain 被设置为设置 Cookie 页面的主机名，我们也可以手动设置 domain 的值：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">Set</span><span style="color:#89DDFF;">-</span><span style="color:#FFCB6B;">Cookie</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> name</span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;">xiuyan</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> domain</span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;">xiuyan</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">me</span></span>
<span class="line"></span></code></pre></div><p>同一个域名下的所有请求，都会携带 Cookie。大家试想，如果我们此刻仅仅是请求一张图片或者一个 CSS 文件，我们也要携带一个 Cookie 跑来跑去（关键是 Cookie 里存储的信息我现在并不需要），这是一件多么劳民伤财的事情。Cookie 虽然小，请求却可以有很多，随着请求的叠加，这样的不必要的 Cookie 带来的开销将是无法想象的。</p><p>随着前端应用复杂度的提高，Cookie 也渐渐演化为了一个“存储多面手”——它不仅仅被用于维持状态，还被塞入了一些乱七八糟的其它信息，被迫承担起了本地存储的“重任”。在没有更好的本地存储解决方案的年代里，Cookie 小小的身体里承载了 4KB 内存所不能承受的压力。</p><p>为了弥补 Cookie 的局限性，让“专业的人做专业的事情”，Web Storage 出现了。</p><h3 id="向前一步-web-storage" tabindex="-1">向前一步：Web Storage <a class="header-anchor" href="#向前一步-web-storage" aria-hidden="true">#</a></h3><p>Web Storage 是 HTML5 专门为浏览器存储而提供的数据存储机制。它又分为 <strong>Local Storage 与 Session Storage</strong>。这两组概念非常相近，我们不妨先理解它们之间的区别，再对它们的共性进行研究。</p><p>Local Storage 与 Session Storage 的区别 两者的区别在于生命周期与作用域的不同。</p><p>生命周期：Local Storage 是持久化的本地存储，存储在其中的数据是永远不会过期的，使其消失的唯一办法是手动删除；而 Session Storage 是临时性的本地存储，它是会话级别的存储，当会话结束（页面被关闭）时，存储内容也随之被释放。</p><p>作用域：Local Storage、Session Storage 和 Cookie 都遵循同源策略。但 Session Storage 特别的一点在于，<strong>即便是相同域名下的两个页面，只要它们不在同一个浏览器窗口中打开，那么它们的 Session Storage 内容便无法共享。</strong></p><h4 id="web-storage-的特性" tabindex="-1">Web Storage 的特性 <a class="header-anchor" href="#web-storage-的特性" aria-hidden="true">#</a></h4><ul><li>存储容量大： Web Storage 根据浏览器的不同，存储容量可以达到 5-10M 之间。</li><li>仅位于浏览器端，不与服务端发生通信。</li></ul><h4 id="web-storage-核心-api-使用示例" tabindex="-1">Web Storage 核心 API 使用示例 <a class="header-anchor" href="#web-storage-核心-api-使用示例" aria-hidden="true">#</a></h4><p>Web Storage 保存的数据内容和 Cookie 一样，是文本内容，以键值对的形式存在。Local Storage 与 Session Storage 在 API 方面无异，这里我们以 localStorage 为例：</p><p>存储数据：setItem() <code>localStorage.setItem(&#39;user_name&#39;, &#39;xiuyan&#39;)</code> 读取数据： getItem() <code>localStorage.getItem(&#39;user_name&#39;)</code> 删除某一键名对应的数据： removeItem() <code>localStorage.removeItem(&#39;user_name&#39;)</code> 清空数据记录：clear() <code>localStorage.clear()</code></p><h3 id="local-storage" tabindex="-1">Local Storage <a class="header-anchor" href="#local-storage" aria-hidden="true">#</a></h3><p>Local Storage 在存储方面没有什么特别的限制，理论上 Cookie 无法胜任的、可以用简单的键值对来存取的数据存储任务，都可以交给 Local Storage 来做。</p><p>这里给大家举个例子，考虑到 Local Storage 的特点之一是<strong>持久</strong>，有时我们更倾向于用它来存储一些内容稳定的资源。比如图片内容丰富的电商网站会用它来存储 Base64 格式的图片字符串</p><p>有的网站还会用它存储一些不经常更新的 CSS、JS 等静态资源。</p><h3 id="session-storage" tabindex="-1">Session Storage <a class="header-anchor" href="#session-storage" aria-hidden="true">#</a></h3><p>Session Storage 更适合用来存储生命周期和它同步的会话级别的信息。这些信息只适用于当前会话，当你开启新的会话时，<strong>它也需要相应的更新或释放</strong>。比如微博的 Session Storage 就主要是存储你本次会话的浏览足迹：</p><p>lasturl 对应的就是你上一次访问的 URL 地址，这个地址是即时的。当你切换 URL 时，它随之更新，当你关闭页面时，留着它也确实没有什么意义了，干脆释放吧。这样的数据用 Session Storage 来处理再合适不过。</p><p>这样看来，Web Storage 确实也够强大了。那么 Web Storage 是否能 hold 住所有的存储场景呢？</p><p>答案是否定的。大家也看到了，Web Storage 是一个从定义到使用都非常简单的东西。它使用键值对的形式进行存储，这种模式有点类似于对象，却甚至连对象都不是——它只能存储字符串，要想得到对象，我们还需要先对字符串进行一轮解析。</p><p>说到底，Web Storage 是对 Cookie 的拓展，它只能用于存储少量的简单数据。当遇到大规模的、结构复杂的数据时，Web Storage 也爱莫能助了。这时候我们就要清楚我们的终极大 boss——IndexedDB！</p><h3 id="终极形态-indexeddb" tabindex="-1">终极形态：IndexedDB <a class="header-anchor" href="#终极形态-indexeddb" aria-hidden="true">#</a></h3><p>IndexedDB 是一个运行在浏览器上的非关系型数据库。既然是数据库了，那就不是 5M、10M 这样小打小闹级别了。理论上来说，IndexedDB 是没有存储上限的（一般来说不会小于 250M）。它不仅可以存储字符串，还可以存储二进制数据。</p><p>通过一个基本的 IndexedDB 使用流程，旨在对 IndexedDB 形成一个感性的认知</p><ol><li>打开/创建一个 IndexedDB 数据库（当该数据库不存在时，open 方法会直接创建一个名为 xiaoceDB 新数据库）。</li><li>创建一个 object store（object store 对标到数据库中的“表”单位）。</li><li>构建一个事务来执行一些数据库操作，像增加或提取数据等。</li><li>通过监听正确类型的事件以等待操作完成。</li></ol><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki"><code><span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;">// 后面的回调中，我们可以通过event.target.result拿到数据库实例</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> db</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;">// 参数1位数据库名，参数2为版本号</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> request </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> window</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">indexedDB</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">open</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">xiaoceDB</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;">// 使用IndexedDB失败时的监听函数</span></span>
<span class="line"><span style="color:#A6ACCD;">  request</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">onerror</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">event</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">     </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">无法使用IndexedDB</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">   </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;">// 成功</span></span>
<span class="line"><span style="color:#A6ACCD;">  request</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">onsuccess</span><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">event</span><span style="color:#89DDFF;">){</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;">// 此处就可以获取到db实例</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">db</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">event</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">target</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">result</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">你打开了IndexedDB</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki"><code><span class="line"><span style="color:#676E95;">// onupgradeneeded事件会在初始化数据库/版本发生更新时被调用，我们在它的监听函数中创建object store</span></span>
<span class="line"><span style="color:#A6ACCD;">request</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">onupgradeneeded</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">event</span><span style="color:#89DDFF;">){</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">objectStore</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;">// 如果同名表未被创建过，则新建test表</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">if</span><span style="color:#F07178;"> (</span><span style="color:#89DDFF;">!</span><span style="color:#A6ACCD;">db</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">objectStoreNames</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">contains</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">test</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">objectStore</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">db</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">createObjectStore</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">test</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> keyPath</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">id</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">  </span></span>
<span class="line"></span></code></pre></div><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki"><code><span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;">// 创建事务，指定表格名称和读写权限</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> transaction </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> db</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">transaction</span><span style="color:#A6ACCD;">([</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">test</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">]</span><span style="color:#89DDFF;">,</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">readwrite</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;">// 拿到Object Store对象</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> objectStore </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> transaction</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">objectStore</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">test</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;">// 向表格写入数据</span></span>
<span class="line"><span style="color:#A6ACCD;">  objectStore</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">add</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span><span style="color:#F07178;">id</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">name</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">xiuyan</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span></code></pre></div><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki"><code><span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;">// 操作成功时的监听函数</span></span>
<span class="line"><span style="color:#A6ACCD;">  transaction</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">oncomplete</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">event</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">操作成功</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;">// 操作失败时的监听函数</span></span>
<span class="line"><span style="color:#A6ACCD;">  transaction</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">onerror</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">event</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">这里有一个Error</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h2 id="cdn的缓存与回源机制解析" tabindex="-1">CDN的缓存与回源机制解析 <a class="header-anchor" href="#cdn的缓存与回源机制解析" aria-hidden="true">#</a></h2><blockquote><p>CDN （Content Delivery Network，即内容分发网络）指的是一组分布在各个地区的服务器。这些服务器存储着数据的副本，因此服务器可以根据哪些服务器与用户距离最近，来满足数据的请求。 CDN 提供快速服务，较少受高流量影响。</p></blockquote><h3 id="为什么要用-cdn" tabindex="-1">为什么要用 CDN <a class="header-anchor" href="#为什么要用-cdn" aria-hidden="true">#</a></h3><p>浏览器存储的相关知识此刻离我们还不太远，大家趁热回忆一下：缓存、本地存储带来的性能提升，是不是只能在“获取到资源并把它们存起来”这件事情发生之后？也就是说，首次请求资源的时候，这些招数都是救不了我们的。要提升首次请求的响应能力，除了我们 2、3、4 节提到的方案之外，我们还需要借助 CDN 的能力。</p><h3 id="cdn的核心功能特写" tabindex="-1">CDN的核心功能特写 <a class="header-anchor" href="#cdn的核心功能特写" aria-hidden="true">#</a></h3><p>CDN 的核心点有两个，一个是<strong>缓存</strong>，一个是<strong>回源</strong>。</p><p>这两个概念都非常好理解。对标到上面描述的过程，“缓存”就是说我们把资源 copy 一份到 CDN 服务器上这个过程，“回源”就是说 CDN 发现自己没有这个资源（一般是缓存的数据过期了），转头向根服务器（或者它的上层服务器）去要这个资源的过程。</p><h3 id="cdn-与前端性能优化" tabindex="-1">CDN 与前端性能优化 <a class="header-anchor" href="#cdn-与前端性能优化" aria-hidden="true">#</a></h3><p>一个彩蛋的自我修养——CDN 往往是被前端认为前端不需要了解的东西。</p><h3 id="cdn-的实际应用" tabindex="-1">CDN 的实际应用 <a class="header-anchor" href="#cdn-的实际应用" aria-hidden="true">#</a></h3><p>静态资源本身具有访问频率高、承接流量大的特点，因此静态资源加载速度始终是前端性能的一个非常关键的指标。CDN 是静态资源提速的重要手段，在许多一线的互联网公司，“静态资源走 CDN”并不是一个建议，而是一个规定。</p><h3 id="cdn-优化细节" tabindex="-1">CDN 优化细节 <a class="header-anchor" href="#cdn-优化细节" aria-hidden="true">#</a></h3><p>如何让 CDN 的效用最大化？这又是需要前后端程序员一起思考的庞大命题。它涉及到 CDN 服务器本身的性能优化、CDN 节点的地址选取等。但我们今天不写高深的论文，只谈离前端最近的这部分细节：CDN 的域名选取。</p><p>大家先回头看一下我刚刚选取的淘宝首页的例子，我们注意到业务服务器的域名是这个：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">www.taobao.com</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>而 CDN 服务器的域名是这个：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">g.alicdn.com</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>没错，我们不一样！</p><p>同一个域名下的请求会不分青红皂白地携带 Cookie，而静态资源往往并不需要 Cookie 携带什么认证信息。把静态资源和主页面置于不同的域名下，完美地避免了不必要的 Cookie 的出现！</p><h2 id="服务端渲染的探索与实践" tabindex="-1">服务端渲染的探索与实践 <a class="header-anchor" href="#服务端渲染的探索与实践" aria-hidden="true">#</a></h2><p>服务端渲染（SSR）近两年炒得很火热，相信各位同学对这个名词多少有所耳闻。本节我们将围绕“是什么”（服务端渲染的运行机制）、“为什么”（服务端渲染解决了什么性能问题 ）、“怎么做”（服务端渲染的应用实例与使用场景）这三个点，对服务端渲染进行探索。</p><h3 id="服务端渲染" tabindex="-1">服务端渲染 <a class="header-anchor" href="#服务端渲染" aria-hidden="true">#</a></h3><p>服务端渲染的模式下，当用户第一次请求页面时，由服务器把需要的组件或页面渲染成 HTML 字符串，然后把它返回给客户端。客户端拿到手的，是可以直接渲染然后呈现给用户的 HTML 内容，不需要为了生成 DOM 内容自己再去跑一遍 JS 代码。</p><p>使用服务端渲染的网站，可以说是“所见即所得”，<strong>页面上呈现的内容，我们在 html 源文件里也能找到</strong>。</p><h3 id="服务端渲染解决了什么性能问题" tabindex="-1">服务端渲染解决了什么性能问题 <a class="header-anchor" href="#服务端渲染解决了什么性能问题" aria-hidden="true">#</a></h3><p>事实上，很多网站是出于效益的考虑才启用服务端渲染，性能倒是在其次。</p><p>假设 A 网站页面中有一个关键字叫“前端性能优化”，这个关键字是 JS 代码跑过一遍后添加到 HTML 页面中的。那么客户端渲染模式下，我们在搜索引擎搜索这个关键字，是找不到 A 网站的——搜索引擎只会查找现成的内容，不会帮你跑 JS 代码。A 网站的运营方见此情形，感到很头大：搜索引擎搜不出来，用户找不到我们，谁还会用我的网站呢？为了把“现成的内容”拿给搜索引擎看，A 网站不得不启用服务端渲染。</p><p>但性能在其次，不代表性能不重要。服务端渲染解决了一个非常关键的性能问题——首屏加载速度过慢。在客户端渲染模式下，我们除了加载 HTML，还要等渲染所需的这部分 JS 加载完，之后还得把这部分 JS 在浏览器上再跑一遍。这一切都是发生在用户点击了我们的链接之后的事情，在这个过程结束之前，用户始终见不到我们网页的庐山真面目，也就是说用户一直在等！相比之下，服务端渲染模式下，服务器给到客户端的已经是一个直接可以拿来呈现给用户的网页，中间环节早在服务端就帮我们做掉了，用户岂不“美滋滋”？</p><p>react服务端渲染 和 vue服务端渲染</p><p>实际项目比这些复杂很多，但万变不离其宗。强调的只有两点：<strong>一是这个 renderToString() 方法；二是把转化结果“塞”进模板里的这一步。这两个操作是服务端渲染的灵魂操作</strong>。在虚拟 DOM“横行”的当下，服务端渲染不再是早年 JSP 里简单粗暴的字符串拼接过程，它还要求这一端要具备将虚拟 DOM 转化为真实 DOM 的能力。与其说是“把 JS 在服务器上先跑一遍”，不如说是“把 Vue、React 等框架代码先在 Node 上跑一遍”。</p><h3 id="服务端渲染的应用场景" tabindex="-1">服务端渲染的应用场景 <a class="header-anchor" href="#服务端渲染的应用场景" aria-hidden="true">#</a></h3><p>打眼一看，这个服务端渲染给浏览器省了这么多事儿，性能肯定是质的飞跃啊！喜闻乐见！但是大家打开自己经常访问的那些网页看一看，会发现仍然有许多网站压根儿不用服务端渲染——看来这个东西也不是万能的。</p><p>根据我们前面的描述，不难看出，服务端渲染本质上是<strong>本该浏览器做的事情，分担给服务器去做</strong>。这样当资源抵达浏览器时，它呈现的速度就快了。乍一看好像很合理：浏览器性能毕竟有限，服务器多牛逼！能者多劳，就该让服务器多干点活！</p><p>但仔细想想，在这个网民遍地的时代，几乎有多少个用户就有多少台浏览器。用户拥有的浏览器总量多到数不清，那么一个公司的服务器又有多少台呢？我们把这么多台浏览器的渲染压力集中起来，分散给相比之下数量并不多的服务器，服务器肯定是承受不住的。</p><p>这样分析下来，服务端渲染也并非万全之策。在实践中，我一般会建议大家先忘记服务端渲染这个事情——服务器稀少而宝贵，但首屏渲染体验和 SEO 的优化方案却很多——我们最好先把能用的低成本“大招”都用完。除非网页对性能要求太高了，以至于所有的招式都用完了，性能表现还是不尽人意，这时候我们就可以考虑向老板多申请几台服务器，把服务端渲染搞起来了~</p><h2 id="浏览器的运行机制" tabindex="-1">浏览器的运行机制 <a class="header-anchor" href="#浏览器的运行机制" aria-hidden="true">#</a></h2><p>开篇我提到许多工程师因为业务需要，免不了需要去处理不同浏览器下代码渲染结果的差异性。这些差异性正是因为浏览器内核的不同而导致的——浏览器内核决定了浏览器解释网页语法的方式。 浏览器内核可以分成两部分：渲染引擎（Layout Engine 或者 Rendering Engine）和 JS 引擎。早期渲染引擎和 JS 引擎并没有十分明确的区分，但随着 JS 引擎越来越独立，内核也成了渲染引擎的代称（下文我们将沿用这种叫法）。渲染引擎又包括了 HTML 解释器、CSS 解释器、布局、网络、存储、图形、音视频、图片解码器等等零部件。</p><p>目前市面上常见的浏览器内核可以分为这四种：Trident（IE）、Gecko（火狐）、Blink（Chrome、Opera）、Webkit（Safari）。</p><p>这里面大家最耳熟能详的可能就是 Webkit 内核了。很多同学可能会听说过 Chrome 的内核就是 Webkit，殊不知 Chrome 内核早已迭代为了 Blink。但是换汤不换药，Blink 其实也是基于 Webkit 衍生而来的一个分支，因此，Webkit 内核仍然是当下浏览器世界真正的霸主。</p><p>下面我们就以 Webkit 为例，对现代浏览器的渲染过程进行一个深度的剖析。</p><p>什么是渲染过程？简单来说，渲染引擎根据 HTML 文件描述构建相应的数学模型，调用浏览器各个零部件，从而将网页资源代码转换为图像结果</p><p>从这个流程来看，浏览器呈现网页这个过程，宛如一个黑盒。在这个神秘的黑盒中，有许多功能模块，内核内部的实现正是这些功能模块相互配合协同工作进行的。其中我们最需要关注的，就是<strong>HTML 解释器</strong>、<strong>CSS 解释器</strong>、<strong>图层布局计算模块</strong>、<strong>视图绘制模块</strong>与<strong>JavaScript 引擎</strong>这几大模块：</p><ul><li>HTML 解释器：将 HTML 文档经过词法分析输出 DOM 树。</li><li>CSS 解释器：解析 CSS 文档, 生成样式规则。</li><li>图层布局计算模块：布局计算每个对象的精确位置和大小。</li><li>视图绘制模块：进行具体节点的图像绘制，将像素渲染到屏幕上。</li><li>JavaScript 引擎：编译执行 Javascript 代码。</li></ul><h3 id="解析过程" tabindex="-1">解析过程 <a class="header-anchor" href="#解析过程" aria-hidden="true">#</a></h3><ul><li><strong>解析 HTML</strong></li></ul><p>在这一步浏览器执行了所有的加载解析逻辑，在解析 HTML 的过程中发出了页面渲染所需的各种外部资源请求。</p><ul><li><strong>计算样式</strong></li></ul><p>浏览器将识别并加载所有的 CSS 样式信息与 DOM 树合并，最终生成页面 render 树（:after :before 这样的伪元素会在这个环节被构建到 DOM 树中）。</p><ul><li><strong>计算图层布局</strong></li></ul><p>页面中所有元素的相对位置信息，大小等信息均在这一步得到计算。</p><ul><li><strong>绘制图层</strong></li></ul><p>在这一步中浏览器会根据我们的 DOM 代码结果，把每一个页面图层转换为像素，并对所有的媒体文件进行解码。</p><ul><li><strong>整合图层，得到页面</strong></li></ul><p>最后一步浏览器会合并合各个图层，将数据由 CPU 输出给 GPU 最终绘制在屏幕上。（复杂的视图层会给这个阶段的 GPU 计算带来一些压力，在实际应用中为了优化动画性能，我们有时会手动区分不同的图层）。</p>`,183),p=[l];function t(r,c,i,d,D,h){return e(),a("div",null,p)}const F=s(o,[["render",t]]);export{y as __pageData,F as default};
