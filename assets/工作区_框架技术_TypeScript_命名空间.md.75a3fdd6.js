import{_ as e,c as t,o as a,a as r}from"./app.64cc5612.js";const f=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"TypeScript 命名空间发展史","slug":"typescript-命名空间发展史","link":"#typescript-命名空间发展史","children":[]},{"level":2,"title":"命名空间和模块区别","slug":"命名空间和模块区别","link":"#命名空间和模块区别","children":[{"level":3,"title":"分离到多文件","slug":"分离到多文件","link":"#分离到多文件","children":[]},{"level":3,"title":"多文件中的命名空间","slug":"多文件中的命名空间","link":"#多文件中的命名空间","children":[]}]}],"relativePath":"工作区/框架技术/TypeScript/命名空间.md"}'),i={name:"工作区/框架技术/TypeScript/命名空间.md"},c=r('<h2 id="typescript-命名空间发展史" tabindex="-1">TypeScript 命名空间发展史 <a class="header-anchor" href="#typescript-命名空间发展史" aria-hidden="true">#</a></h2><p>“内部模块”现在叫做“命名空间”，任何使用<code>module</code>关键字来声明一个内部模块的地方都应该使用<code>namespace</code>关键字来替换。这就避免了让新的使用者被相似的名称所迷惑。</p><h2 id="命名空间和模块区别" tabindex="-1">命名空间和模块区别 <a class="header-anchor" href="#命名空间和模块区别" aria-hidden="true">#</a></h2><p>命名空间可以看做是一个微型模块。当我们先把相关的业务代码写在一起，又不想污染全局空间的时候，我们就可以使用命名空间。<strong>命名空间本质就是定义一个大对象，把变量/方法/类/接口...的都放里面。</strong></p><p>在程序内部使用的代码，可以使用命名空间封装和防止全局污染；在程序外部使用的代码，可以使用模块封装和防止全局污染。由于模块也能实现相同的功能，所以大部分情况下用模块即可。</p><h3 id="分离到多文件" tabindex="-1">分离到多文件 <a class="header-anchor" href="#分离到多文件" aria-hidden="true">#</a></h3><p>当应用变得越来越大时，我们需要将代码分离到不同的文件中以便于维护。</p><h3 id="多文件中的命名空间" tabindex="-1">多文件中的命名空间 <a class="header-anchor" href="#多文件中的命名空间" aria-hidden="true">#</a></h3><p>现在，我们把Validation命名空间分割成多个文件。尽管是不同的文件，它们仍是同一个命名空间，并且在使用的时候就如同它们在一个文件中定义的一样。因为不同文件之间存在依赖关系，所以我们加入了引用标签来告诉编译器文件之间的关联。我们的测试代码保持不变。</p>',9),d=[c];function n(s,l,p,o,h,_){return a(),t("div",null,d)}const m=e(i,[["render",n]]);export{f as __pageData,m as default};
