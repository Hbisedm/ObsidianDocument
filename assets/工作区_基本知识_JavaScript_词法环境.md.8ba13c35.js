import{_ as s,c as a,d as e,a as o,b as n,o as t}from"./app.c99ff793.js";const k=JSON.parse('{"title":"词法环境的笔记","description":"","frontmatter":{"title":"词法环境的笔记","tags":["词法环境"],"创建时间":"星期三, 七月 27日 2022, 8:58:57 晚上","修改时间":"星期日, 八月 7日 2022, 3:07:20 下午"},"headers":[{"level":2,"title":"变量","slug":"变量","link":"#变量","children":[]},{"level":2,"title":"函数声明","slug":"函数声明","link":"#函数声明","children":[]},{"level":2,"title":"内部和外部的词法环境","slug":"内部和外部的词法环境","link":"#内部和外部的词法环境","children":[]},{"level":2,"title":"返回函数","slug":"返回函数","link":"#返回函数","children":[]}],"relativePath":"工作区/基本知识/JavaScript/词法环境.md"}'),l={name:"工作区/基本知识/JavaScript/词法环境.md"},r=o('<p>#JavaScript</p><h1 id="词法环境的笔记" tabindex="-1">词法环境的笔记 <a class="header-anchor" href="#词法环境的笔记" aria-hidden="true">#</a></h1><p>在 JavaScript 中，每个运行的函数，代码块 <code>{...}</code> 以及整个脚本，都有一个被称为 <strong>词法环境（Lexical Environment）</strong> 的内部（隐藏）的<strong>关联对象</strong>。</p><p>词法环境对象由两部分组成：</p><ol><li><strong>环境记录（Environment Record）</strong> —— 一个存储所有局部变量作为其属性（包括一些其他信息，例如 <code>this</code> 的值）的对象。</li><li>对 <strong>外部词法环境</strong> 的引用，与外部代码相关联。</li></ol><h2 id="变量" tabindex="-1">变量 <a class="header-anchor" href="#变量" aria-hidden="true">#</a></h2><p>一个“变量”只是 <strong>环境记录</strong> 这个特殊的内部对象的一个属性。“获取或修改变量”意味着“获取或修改词法环境的一个属性”。</p><img src="https://zh.javascript.info/article/closure/closure-variable-phrase.svg"><p>右侧的矩形演示了执行过程中全局词法环境的变化：</p><ol><li>当脚本开始运行，词法环境预先填充了所有声明的变量。 <ul><li>最初，它们处于“未初始化（Uninitialized）”状态。这是一种特殊的内部状态，这意味着引擎知道变量，但是在用 <code>let</code> 声明前，不能引用它。几乎就像变量不存在一样。</li></ul></li><li>然后 <code>let phrase</code> 定义出现了。它尚未被赋值，因此它的值为 <code>undefined</code>。从这一刻起，我们就可以使用变量了。</li><li><code>phrase</code> 被赋予了一个值。</li><li><code>phrase</code> 的值被修改。</li></ol><blockquote><p>“词法环境”是一个规范对象（specification object）：它仅仅是存在于 <a href="https://tc39.es/ecma262/#sec-lexical-environments" target="_blank" rel="noreferrer">编程语言规范</a> 中的“理论上”存在的，用于描述事物如何运作的对象。我们无法在代码中获取该对象并直接对其进行操作。 但 JavaScript 引擎同样可以优化它，比如清除未被使用的变量以节省内存和执行其他内部技巧等，但显性行为应该是和上述的无差。</p></blockquote><h2 id="函数声明" tabindex="-1">函数声明 <a class="header-anchor" href="#函数声明" aria-hidden="true">#</a></h2><p>一个函数其实也是一个值，就像变量一样。</p><p><strong>不同之处在于函数声明的初始化会被立即完成。</strong></p><p>当创建了一个词法环境（Lexical Environment）时，函数声明会立即变为即用型函数（不像 <code>let</code> 那样直到声明处才可用）。</p><p>这就是为什么我们可以在（函数声明）的定义之前调用函数声明。</p><p>例如，这是添加一个函数时全局词法环境的初始状态：</p><img src="https://zh.javascript.info/article/closure/closure-function-declaration.svg"><p>正常来说，这种行为仅适用于函数声明，而不适用于我们将函数分配给变量的函数表达式，例如 <code>let say = function(name)...</code>。</p><blockquote><p>函数声明在初始化的时候就可以拿到了。</p></blockquote><h2 id="内部和外部的词法环境" tabindex="-1">内部和外部的词法环境 <a class="header-anchor" href="#内部和外部的词法环境" aria-hidden="true">#</a></h2><p>在一个函数运行时，在调用刚开始时，会自动创建一个新的词法环境以存储这个调用的局部变量和参数。</p><p>例如，对于 <code>say(&quot;John&quot;)</code>，它看起来像这样（当前执行位置在箭头标记的那一行上）：</p><img src="https://zh.javascript.info/article/closure/lexical-environment-simple.svg">',24),c=o(`<ul><li>内部词法环境与 <code>say</code> 的当前执行相对应。它具有一个单独的属性：<code>name</code>，函数的参数。我们调用的是 <code>say(&quot;John&quot;)</code>，所以 <code>name</code> 的值为 <code>&quot;John&quot;</code>。</li><li>外部词法环境是全局词法环境。它具有 <code>phrase</code> 变量和函数本身。</li></ul><p>内部词法环境引用了 <code>outer</code>。</p><p><strong>当代码要访问一个变量时 —— 首先会搜索内部词法环境，然后搜索外部环境，然后搜索更外部的环境，以此类推，直到全局词法环境。</strong></p><h2 id="返回函数" tabindex="-1">返回函数 <a class="header-anchor" href="#返回函数" aria-hidden="true">#</a></h2><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">makeCounter</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">count</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">	 </span><span style="color:#89DDFF;">return</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">		  </span><span style="color:#89DDFF;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">count</span><span style="color:#89DDFF;">++;</span><span style="color:#F07178;"> </span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> counter </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">makeCounter</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre></div><p>在每次 <code>makeCounter()</code> 调用的开始，都会创建一个新的词法环境对象，以存储该 <code>makeCounter</code> 运行时的变量。</p><img src="https://zh.javascript.info/article/closure/closure-makecounter.svg">`,7),p=n("p",null,[n("strong",null,"所有的函数在“诞生”时都会记住创建它们的词法环境"),e("。从技术上讲，这里没有什么魔法："),n("strong",null,[e("所有函数都有名为 "),n("code",null,"[[Environment]]"),e(" 的隐藏属性")]),e("，该属性保存了对创建该函数的"),n("strong",null,"词法环境的引用"),e("。")],-1),i=n("img",{src:"https://zh.javascript.info/article/closure/closure-makecounter-environment.svg"},null,-1),d=o('<p>因此，<code>counter.[[Environment]]</code> 有对 <code>{count: 0}</code> 词法环境的引用。这就是函数记住它创建于何处的方式，与函数被在哪儿调用无关。<code>[[Environment]]</code> 引用在函数创建时被设置并永久保存。</p><p>稍后，当调用 <code>counter()</code> 时，会为该调用创建一个新的词法环境，并且其外部词法环境引用<strong>获取</strong>于 <code>counter.[[Environment]]</code>：</p><img src="https://zh.javascript.info/article/closure/closure-makecounter-nested-call.svg">',3),u=n("p",null,[n("strong",null,"在变量所在的词法环境中更新变量。")],-1),_=n("p",null,"这是执行后的状态：",-1),h=n("img",{src:"https://zh.javascript.info/article/closure/closure-makecounter-nested-call-2.svg"},null,-1),g=o('<blockquote><p>闭包 开发者通常应该都知道“闭包”这个通用的编程术语。 <a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)" target="_blank" rel="noreferrer">闭包</a> 是指一个函数可以记住其外部变量并可以访问这些变量。在某些编程语言中，这是不可能的，或者应该以一种特殊的方式编写函数来实现。但如上所述，在 JavaScript 中，所有函数都是天生闭包的（只有一个例外，将在 <a href="https://zh.javascript.info/new-function" target="_blank" rel="noreferrer">&quot;new Function&quot; 语法</a> 中讲到）。 也就是说：JavaScript 中的函数会自动通过隐藏的 <code>[[Environment]]</code> 属性记住创建它们的位置，所以它们都可以访问外部变量。 在面试时，前端开发者通常会被问到“什么是闭包？”，正确的回答应该是闭包的定义，并解释清楚为什么 JavaScript 中的所有函数都是闭包的，以及可能的关于 <code>[[Environment]]</code> 属性和词法环境原理的技术细节。</p></blockquote><p><a href="https://zh.javascript.info/closure#step-1-bian-liang" target="_blank" rel="noreferrer">词法环境</a><a href="https://zhuanlan.zhihu.com/p/53135129" target="_blank" rel="noreferrer">傻傻分不清的javascript运行机制 - 知乎</a><a href="https://juejin.cn/post/6896668614272024589" target="_blank" rel="noreferrer">深入浅出执行上下文、词法环境、变量环境 </a></p>',2);function m(v,y,F,f,C,D){return t(),a("div",null,[r,e(" 在这个函数调用期间，我们有两个词法环境：内部一个（用于函数调用）和外部一个（全局）： "),c,e(" 不同的是，在执行 `makeCounter()` 的过程中创建了一个仅占一行的嵌套函数：`return count++`。我们尚未运行它，仅创建了它。 "),p,i,e(" > 闭包就是这样出来的 "),d,e(" 现在，当 `counter()` 中的代码查找 `count` 变量时，它首先搜索自己的词法环境（为空，因为那里没有局部变量），然后是外部 `makeCounter()` 的词法环境，并且在哪里找到就在哪里修改。 "),u,_,h,e(" 如果我们调用 `counter()` 多次，`count` 变量将在同一位置增加到 `2`，`3` 等。 "),g])}const T=s(l,[["render",m]]);export{k as __pageData,T as default};
