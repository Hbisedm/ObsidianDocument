import{_ as s,c as a,b as e,d as o,a as n,o as t}from"./app.0b246d93.js";const k=JSON.parse('{"title":"词法环境的笔记","description":"","frontmatter":{"title":"词法环境的笔记","tags":["词法环境"],"创建时间":"星期三, 七月 27日 2022, 8:58:57 晚上","修改时间":"星期日, 八月 7日 2022, 3:07:20 下午"},"headers":[{"level":2,"title":"变量","slug":"变量","link":"#变量","children":[]},{"level":2,"title":"函数声明","slug":"函数声明","link":"#函数声明","children":[]},{"level":2,"title":"内部和外部的词法环境","slug":"内部和外部的词法环境","link":"#内部和外部的词法环境","children":[]},{"level":2,"title":"返回函数","slug":"返回函数","link":"#返回函数","children":[]}],"relativePath":"工作区/基本知识/JavaScript/词法环境.md"}'),l={name:"工作区/基本知识/JavaScript/词法环境.md"},r=o("",24),c=o("",7),p=n("p",null,[n("strong",null,"所有的函数在“诞生”时都会记住创建它们的词法环境"),e("。从技术上讲，这里没有什么魔法："),n("strong",null,[e("所有函数都有名为 "),n("code",null,"[[Environment]]"),e(" 的隐藏属性")]),e("，该属性保存了对创建该函数的"),n("strong",null,"词法环境的引用"),e("。")],-1),i=n("img",{src:"https://zh.javascript.info/article/closure/closure-makecounter-environment.svg"},null,-1),d=o("",3),u=n("p",null,[n("strong",null,"在变量所在的词法环境中更新变量。")],-1),_=n("p",null,"这是执行后的状态：",-1),h=n("img",{src:"https://zh.javascript.info/article/closure/closure-makecounter-nested-call-2.svg"},null,-1),g=o("",2);function m(v,y,F,f,C,D){return t(),a("div",null,[r,e(" 在这个函数调用期间，我们有两个词法环境：内部一个（用于函数调用）和外部一个（全局）： "),c,e(" 不同的是，在执行 `makeCounter()` 的过程中创建了一个仅占一行的嵌套函数：`return count++`。我们尚未运行它，仅创建了它。 "),p,i,e(" > 闭包就是这样出来的 "),d,e(" 现在，当 `counter()` 中的代码查找 `count` 变量时，它首先搜索自己的词法环境（为空，因为那里没有局部变量），然后是外部 `makeCounter()` 的词法环境，并且在哪里找到就在哪里修改。 "),u,_,h,e(" 如果我们调用 `counter()` 多次，`count` 变量将在同一位置增加到 `2`，`3` 等。 "),g])}const T=s(l,[["render",m]]);export{k as __pageData,T as default};
