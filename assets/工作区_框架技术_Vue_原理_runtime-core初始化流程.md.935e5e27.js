import{_ as s,c as n,o as a,a as l}from"./app.6426b36b.js";const d=JSON.parse('{"title":"runtime-core初始化流程的笔记","description":"","frontmatter":{"title":"runtime-core初始化流程的笔记","tags":["runtime初始化流程"],"创建时间":"星期四, 八月 25日 2022, 10:34:15 晚上","修改时间":"星期五, 八月 26日 2022, 11:18:43 晚上"},"headers":[{"level":2,"title":"简单理解","slug":"简单理解","link":"#简单理解","children":[]},{"level":2,"title":"创建虚拟节点","slug":"创建虚拟节点","link":"#创建虚拟节点","children":[{"level":3,"title":"vnode.type","slug":"vnode-type","link":"#vnode-type","children":[]},{"level":3,"title":"vnode.shapeFlag","slug":"vnode-shapeflag","link":"#vnode-shapeflag","children":[]}]},{"level":2,"title":"Render","slug":"render","link":"#render","children":[{"level":3,"title":"简单描述patch","slug":"简单描述patch","link":"#简单描述patch","children":[]}]},{"level":2,"title":"开始处理挂载","slug":"开始处理挂载","link":"#开始处理挂载","children":[]}],"relativePath":"工作区/框架技术/Vue/原理/runtime-core初始化流程.md"}'),e={name:"工作区/框架技术/Vue/原理/runtime-core初始化流程.md"},o=l(`<p>#Vue #初始化</p><h1 id="runtime-core初始化流程的笔记" tabindex="-1">runtime-core初始化流程的笔记 <a class="header-anchor" href="#runtime-core初始化流程的笔记" aria-hidden="true">#</a></h1><blockquote><p>解析Vue如何把一个JavaScript对象变成一个真实Dom的初始化过程</p></blockquote><h2 id="简单理解" tabindex="-1">简单理解 <a class="header-anchor" href="#简单理解" aria-hidden="true">#</a></h2><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki"><code><span class="line"><span style="color:#82AAFF;">createApp</span><span style="color:#A6ACCD;">(App)</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">mount</span><span style="color:#A6ACCD;">(rootContainer)</span></span>
<span class="line"></span></code></pre></div><p>createApp创建一个对象, 这个对象是最开始的入口, 其作用是:</p><ul><li>创建APP的虚拟节点</li><li>mount方法用于挂载到指定的容器(使用render进行挂载)</li></ul><p>遍历虚拟节点的children是采用深度优先遍历的原则</p><h2 id="创建虚拟节点" tabindex="-1">创建虚拟节点 <a class="header-anchor" href="#创建虚拟节点" aria-hidden="true">#</a></h2><p>一个虚拟节点包含这些属性 (最核心的属性)</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> vnode </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    type</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;">//类型</span></span>
<span class="line"><span style="color:#A6ACCD;">    props</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;">// props</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">key</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> props </span><span style="color:#89DDFF;">&amp;&amp;</span><span style="color:#A6ACCD;"> props</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">key</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;">// key</span></span>
<span class="line"><span style="color:#A6ACCD;">    children</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;">// 子节点</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">component</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null,</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;">//若是组件的话, 有这个属性</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">el</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null,</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;">// 对应真实DOM</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">shapeFlag</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">getShapeFlag</span><span style="color:#A6ACCD;">(type)</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;">// 虚拟节点类型</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h3 id="vnode-type" tabindex="-1">vnode.type <a class="header-anchor" href="#vnode-type" aria-hidden="true">#</a></h3><p>如果是对象 =&gt; 组件类型 <code>{name: &#39;App&#39; ...}</code> 如果是字符串 =&gt; Element类型 <code>&quot;&lt;div&gt;&quot;</code></p><h3 id="vnode-shapeflag" tabindex="-1">vnode.shapeFlag <a class="header-anchor" href="#vnode-shapeflag" aria-hidden="true">#</a></h3><p>定义这个属性是为了后续处理VNode好判断并进行相对的逻辑处理</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki"><code><span class="line"><span style="color:#89DDFF;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">enum</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">ShapeFlags</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  ELEMENT </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;">//元素</span></span>
<span class="line"><span style="color:#A6ACCD;">  STATEFUL_COMPONENT </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;&lt;</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;">// 组件</span></span>
<span class="line"><span style="color:#A6ACCD;">  TEXT_CHILDREN </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;&lt;</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;">// 文本</span></span>
<span class="line"><span style="color:#A6ACCD;">  ARRAY_CHILDREN </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;&lt;</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">3</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;">// 包含多个子节点的组件或元素</span></span>
<span class="line"><span style="color:#A6ACCD;">  SLOT_CHILDREN </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;&lt;</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">4</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;">// slot</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h2 id="render" tabindex="-1">Render <a class="header-anchor" href="#render" aria-hidden="true">#</a></h2><p>render是最开始入口, 里面最核心的方法是<code>patch</code> 它是处理所有VNode的统一入口。</p><h3 id="简单描述patch" tabindex="-1">简单描述patch <a class="header-anchor" href="#简单描述patch" aria-hidden="true">#</a></h3><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">patch</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">n1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;">n2</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">any</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;">container</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">any</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;">parentComponent</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;">anchor</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">	  </span><span style="color:#676E95;">//...</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><ul><li>n1: 老节点</li><li>n2: 新节点</li><li>container: 容器</li><li>parentComponent: 当前patch时父组件实例</li><li>anchor: vnode挂载到真实DOM的锚点</li></ul><p>第一次进入patch</p><ul><li>n1肯定为null</li><li>n2为当前的App VNode</li><li>container为挂载到rootContainer</li><li>parentComponent和anchor也肯定为null</li></ul><p>判断是组件还是元素 App肯定是组件嘛 进入组件的逻辑 判断是挂载还是更新 第一次进来肯定是挂载嘛, 进入挂载逻辑</p><h2 id="开始处理挂载" tabindex="-1">开始处理挂载 <a class="header-anchor" href="#开始处理挂载" aria-hidden="true">#</a></h2><ol><li><p>创建组件实例对象<code>createComponentInstance</code> 拿到<code>componentInstance</code></p></li><li><p><code>setupComponent(instance)</code> 安装组件实例, 这里主要处理:</p><ul><li><code>initProps</code></li><li><code>initSlots</code></li><li><code>setupStatefulComponent</code> <strong>执行了setup, 并将返回值转成个代理对象</strong>丢到<code>instance.setupState</code></li><li><code>finishComponentSetup</code> <strong>确认下render函数</strong> 为接下来的<code>setupRenderEffect</code>做准备 处理完毕后</li></ul></li><li><p><code>setupRenderEffect</code> 组件渲染副作用函数, 这里使用响应式系统的<code>effect</code> 将渲染的逻辑丢到里面 做依赖收集与触发:</p><ul><li>拿组件实例的<code>proxy</code>作为调用<code>render</code>的this</li><li><code>render</code>的返回结果是个 子虚拟节点</li><li>接下来开始进行对子虚拟节点进行<code>patch</code></li><li>patch后就拿到<code>$el</code></li><li>并将当前组件的<code>mounted</code>设置<code>true</code></li></ul></li></ol>`,26),p=[o];function t(c,r,i,C,y,D){return a(),n("div",null,p)}const F=s(e,[["render",t]]);export{d as __pageData,F as default};
