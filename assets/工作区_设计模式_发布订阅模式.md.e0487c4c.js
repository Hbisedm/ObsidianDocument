import{_ as e,c as a,o as i,a as l}from"./app.d0c2f5ea.js";const f=JSON.parse('{"title":"发布订阅模式的笔记","description":"","frontmatter":{"title":"发布订阅模式的笔记","tags":["发布订阅模式"],"创建时间":"星期日, 八月 7日 2022, 12:04:18 凌晨","修改时间":"星期日, 八月 7日 2022, 12:10:48 凌晨"},"headers":[{"level":2,"title":"理解","slug":"理解","link":"#理解","children":[]},{"level":2,"title":"优点","slug":"优点","link":"#优点","children":[]},{"level":2,"title":"缺点","slug":"缺点","link":"#缺点","children":[]}],"relativePath":"工作区/设计模式/发布订阅模式.md"}'),t={name:"工作区/设计模式/发布订阅模式.md"},r=l('<p>#发布订阅模式 #设计模式</p><h1 id="发布订阅模式的笔记" tabindex="-1">发布订阅模式的笔记 <a class="header-anchor" href="#发布订阅模式的笔记" aria-hidden="true">#</a></h1><h2 id="理解" tabindex="-1">理解 <a class="header-anchor" href="#理解" aria-hidden="true">#</a></h2><ul><li>订阅者</li><li>发布者</li></ul><p>解除对象之间的耦合，订阅者不需要关系发布者，发布者不需要关系谁消费。</p><blockquote><p>好多都用到这个设计模式 消息中间件 vue响应式对象 rxjs mvc ....</p></blockquote><h2 id="优点" tabindex="-1">优点 <a class="header-anchor" href="#优点" aria-hidden="true">#</a></h2><ul><li>时间上解耦</li><li>对象之间解耦</li><li>可以使用在异步编程</li></ul><p>发布订阅还可以帮助一些别的设计模式。中介者模式。 无论是 MVC 还是 MVVM 少不了发布订阅模式的参与，且 JavaScript 也是一门基于事件驱动的语言。</p><h2 id="缺点" tabindex="-1">缺点 <a class="header-anchor" href="#缺点" aria-hidden="true">#</a></h2><ul><li>创建订阅者对象消耗一定的时间和内存</li><li>当订阅后，消息事件到最后没发出，那么这个订阅者就始终存在内存中占用</li><li>发布订阅可以弱化对象之间的联系。过度使用的话，对象之间的必要联系将被深埋在背后。会导致维护程序的成本上升。特别是多个发布者和订阅者嵌套到一起的时候，要跟踪一个 bug 不是一件轻松的事情。</li></ul>',11),n=[r];function d(c,s,_,h,o,u){return i(),a("div",null,n)}const m=e(t,[["render",d]]);export{f as __pageData,m as default};
