import{_ as e,c as t,o as a,a as c}from"./app.0b159a37.js";const _=JSON.parse('{"title":"watch与computed","description":"","frontmatter":{"title":"watch与computed","tags":["Vue"],"excerpt":"Vue的watch与computed","创建时间":"星期三, 七月 27日 2022, 8:58:57 晚上","修改时间":"星期五, 十二月 2日 2022, 11:54:47 中午"},"headers":[{"level":2,"title":"Computed:","slug":"computed","link":"#computed","children":[{"level":3,"title":"使用场景","slug":"使用场景","link":"#使用场景","children":[]}]},{"level":2,"title":"Watch:","slug":"watch","link":"#watch","children":[]},{"level":2,"title":"小结:","slug":"小结","link":"#小结","children":[]}],"relativePath":"工作区/框架技术/Vue/开发操作/watch与computed.md"}'),i={name:"工作区/框架技术/Vue/开发操作/watch与computed.md"},l=c('<h1 id="watch与computed" tabindex="-1">watch与computed <a class="header-anchor" href="#watch与computed" aria-hidden="true">#</a></h1><h2 id="computed" tabindex="-1">Computed: <a class="header-anchor" href="#computed" aria-hidden="true">#</a></h2><ul><li>computed是计算属性,也就是计算值,它更多用于计算值的场景</li><li>computed具有缓存性,computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取computed的值时才会重新调用对应的getter来计算 computed适用于计算比较消耗性能的计算场景</li></ul><h3 id="使用场景" tabindex="-1">使用场景 <a class="header-anchor" href="#使用场景" aria-hidden="true">#</a></h3><ul><li>数据的拼接和计算 (计算购物车的选中状态，随着响应式对象的变化对应渲染变化)</li><li>复用组件的动态数据 (不用场景请求不同接口，获取相同数据结构，渲染复用组件)</li><li>获取多级对象的值 (优雅，不用跑火车的写法)</li><li>不同类型的数据转换( 将逗号隔开的字符串，转成数组， 然后渲染一个个元素 )</li></ul><h2 id="watch" tabindex="-1">Watch: <a class="header-anchor" href="#watch" aria-hidden="true">#</a></h2><ul><li>更多的是「观察」的作用,类似于某些数据的监听回调,用于观察props $emit或者本组件的值,当数据变化时来执行回调进行后续操作</li><li>无缓存性，页面重新渲染时值不变化也会执行</li></ul><h2 id="小结" tabindex="-1">小结: <a class="header-anchor" href="#小结" aria-hidden="true">#</a></h2><ul><li>当我们要进行数值计算,而且依赖于其他数据，那么把这个数据设计为computed</li><li>如果你需要在某个数据变化时做一些事情，使用watch来观察这个数据变化</li></ul>',9),d=[l];function h(r,o,u,n,s,p){return a(),t("div",null,d)}const w=e(i,[["render",h]]);export{_ as __pageData,w as default};
