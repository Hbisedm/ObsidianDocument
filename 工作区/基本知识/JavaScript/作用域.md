-   作用域： 作用域是定义变量的区域，它有一套访问变量的规则，这套规则来管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量（标识符）进行变量查找
-   作用域链： 作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和 函数。

> 作用域链的本质上是一个指向**变量对象**的指针列表。**变量对象**是一个包含了执行环境中所有变量和函数的**对象**。作用域链的前 端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。

-   当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向后查找
-   作用域链的创建过程跟执行上下文的建立有关…

### 作用域可以理解为变量的可访问性，总共分为三种类型，分别为：

-   全局作用域
-   函数作用域
-   块级作用域，ES6 中的 let、const 就可以产生该作用域

### 作用域链的概念

> 一旦我们将这些作用域嵌套起来，就变成了另外一个重要的知识点「作用域链」，也就是 JS 到底是如何访问需要的变量或者函数的。

-   首先作用域链是在定义时就被确定下来的，和箭头函数里的 this 一样，后续不会改变，JS 会一层层往上寻找需要的内容。
-   其实作用域链这个东西我们在闭包小结中已经看到过它的实体了：`[[Scopes]]` 
  ![](https://raw.githubusercontent.com/Hbisedm/my-blob-picGo/main/img/202206100848520.png)


> [[Scopes]] 是个数组，作用域的一层层往上寻找就等同于遍历 [[Scopes]]。

### 1.全局作用域

> 全局变量是挂载在 window 对象下的变量，所以在网页中的任何位置你都可以使用并且访问到这个全局变量

```
var globalName = 'global';
function getName() { 
  console.log(globalName) // global
  var name = 'inner'
  console.log(name) // inner
} 
getName();
console.log(name); // 
console.log(globalName); //global
function setName(){ 
  vName = 'setName';
}
setName();
console.log(vName); // setName 
```

-   从这段代码中我们可以看到，globalName 这个变量无论在什么地方都是可以被访问到的，所以它就是全局变量。而在 getName 函数中作为局部变量的 name 变量是不具备这种能力的
-   当然全局作用域有相应的缺点，我们定义很多全局变量的时候，会容易引起变量命名的冲突，所以在定义变量的时候应该注意作用域的问题。

### 2. 函数作用域

> 函数中定义的变量叫作函数变量，这个时候只能在函数内部才能访问到它，所以它的作用域也就是函数的内部，称为函数作用域

```
function getName () {
  var name = 'inner';
  console.log(name); //inner
}
getName();
console.log(name); 
```

-   除了这个函数内部，其他地方都是不能访问到它的。同时，当这个函数被执行完之后，这个局部变量也相应会被销毁。所以你会看到在 getName 函数外面的 name 是访问不到的 **(闭包除外)**

### 3. 块级作用域

> ES6 中新增了块级作用域，最直接的表现就是新增的 let 关键词，使用 let 关键词定义的变量只能在块级作用域中被访问，有“**暂时性死区**”的特点，也就是说这个变量在定义之前是不能被使用的。 在 JS 编码过程中 if 语句及 for 语句后面 {…} 这里面所包括的，就是块级作用域

```
console.log(a) //a is not defined
if(true){
  let a = '123'；
  console.log(a)； // 123
}
console.log(a) //a is not defined 
```

> 从这段代码可以看出，变量 a 是在 if 语句{…} 中由 let 关键词进行定义的变量，所以它的作用域是 if 语句括号中的那部分，而在外面进行访问 a 变量是会报错的，**因为这里不是它的作用域**。所以在 if 代码块的前后输出 a 这个变量的结果，控制台会显示 a 并没有定义