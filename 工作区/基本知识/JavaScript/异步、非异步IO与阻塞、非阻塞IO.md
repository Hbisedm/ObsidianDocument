---
title: 异步、非异步IO与阻塞、非阻塞IO
创建时间: 星期三, 七月 27日 2022, 8:58:57 晚上
修改时间: 星期一, 十一月 21日 2022, 11:34:10 中午
---
#异步 #io

# 异步、非异步IO与阻塞、非阻塞IO

## 什么是I/O？

> IO有内存IO、网络IO和磁盘IO三种，通常我们说的IO指的是后两者。

首先，我想有必要把 I/O 的概念解释一下。I/O 即Input/Output, 输入和输出的意思。在浏览器端，只有一种 I/O，那就是利用 Ajax 发送网络请求，然后读取返回的内容，这属于`网络I/O`。回到 nodejs 中，其实这种的 I/O 的场景就更加广泛了，主要分为两种:

- 文件 I/O。比如用 fs 模块对文件进行读写操作。
- 网络 I/O。比如 http 模块发起网络请求。

### I/O过程

![](https://raw.githubusercontent.com/Hbisedm/my-blob-picGo/main/img/202211211112774.png)


对于一个输入操作来说，进程IO系统调用后，内核会先看缓冲区中有没有相应的缓存数据，没有的话再到设备中读取，因为设备IO一般速度较慢，需要等待；内核缓冲区有数据则直接复制到进程空间。

所以，对于一个网络输入操作通常包括两个不同阶段：

- 等待网络数据到达网卡→读取到内核缓冲区，数据准备好；
- 从内核缓冲区复制数据到进程空间。

## I/O模型类型

- 阻塞IO
- 非阻塞IO
- IO复用模型
- 信号驱动的IO模型
- 异步IO模型

前四种都是**同步**IO模型，最后一个是**异步**IO

### 阻塞IO

![](https://raw.githubusercontent.com/Hbisedm/my-blob-picGo/main/img/202211211127225.png)


1、典型应用：阻塞socket、Java BIO；

2、特点：

- 进程阻塞挂起不消耗CPU资源，及时响应每个操作；
- 实现难度低、开发应用较容易；
- 适用并发量小的网络应用开发；

不适用并发量大的应用：因为一个请求IO会阻塞进程，所以，得为每请求分配一个处理进程（线程）以及时响应，系统开销大。

### 非阻塞IO

![](https://raw.githubusercontent.com/Hbisedm/my-blob-picGo/main/img/202211211127184.png)

进程发起IO系统调用后，如果内核缓冲区没有数据，需要到IO设备中读取，进程返回一个错误而不会被阻塞；进程发起IO系统调用后，如果内核缓冲区有数据，内核就会把数据返回进程。

对于上面的阻塞IO模型来说，内核数据没准备好需要进程阻塞的时候，就返回一个错误，以使得进程不被阻塞。

1、典型应用：socket是非阻塞的方式（设置为NONBLOCK）

2、特点：

- 进程轮询（重复）调用，消耗CPU的资源；
- 实现难度低、开发应用相对阻塞IO模式较难；
- 适用并发量较小、且不需要及时响应的网络应用开发；

### IO复用模型

![](https://raw.githubusercontent.com/Hbisedm/my-blob-picGo/main/img/202211211128209.png)

多个的进程的IO可以注册到一个复用器（select）上，然后用一个进程调用该select， select会监听所有注册进来的IO；

如果select没有监听的IO在内核缓冲区都没有可读数据，select调用进程会被阻塞；而当任一IO在内核缓冲区中有可数据时，select调用就会返回；

而后select调用进程可以自己或通知另外的进程（注册进程）来再次发起读取IO，读取内核中准备好的数据。

可以看到，多个进程注册IO后，只有另一个select调用进程被阻塞。

1、典型应用：select、poll、epoll三种方案，nginx都可以选择使用这三个方案;Java NIO;

2、特点：

- 专一进程解决多个进程IO的阻塞问题，性能好；Reactor模式;
- 实现、开发应用难度较大；
- 适用高并发服务应用开发：一个进程（线程）响应多个请求；

3、select、poll、epoll

- Linux中IO复用的实现方式主要有select、poll和epoll：
- Select：注册IO、阻塞扫描，监听的IO最大连接数不能多于FD_SIZE；
- Poll：原理和Select相似，没有数量限制，但IO数量大扫描线性性能下降；
- Epoll ：事件驱动不阻塞，mmap实现内核与用户空间的消息传递，数量很大，Linux2.6后内核支持；

### 信号驱动IO模型

![](https://raw.githubusercontent.com/Hbisedm/my-blob-picGo/main/img/202211211133528.png)

当进程发起一个IO操作，会向内核注册一个信号处理函数，然后进程返回不阻塞；当内核数据就绪时会发送一个信号给进程，进程便在信号处理函数中调用IO读取数据。

特点：回调机制，实现、开发应用难度大

### 异步IO模型

![](https://raw.githubusercontent.com/Hbisedm/my-blob-picGo/main/img/202211211133277.png)

当进程发起一个IO操作，进程返回（不阻塞），但也不能返回果结；内核把整个IO处理完后，会通知进程结果。如果IO操作成功则进程直接获取到数据。

1、典型应用：JAVA7 AIO、高性能[服务器](https://cloud.tencent.com/product/cvm?from=10680)应用

2、特点：

- 不阻塞，数据一步到位；Proactor模式；
- 需要操作系统的底层支持，LINUX 2.5 版本内核首现，2.6 版本产品的内核标准特性；
- 实现、开发应用难度大；
- 非常适合高性能高并发应用；

## node中的阻塞和非阻塞I/O

> 探索node对于IO模型的操作

`阻塞`和`非阻塞` I/O 其实是针对操作系统内核而言的，而不是 nodejs 本身。阻塞 I/O 的特点就是一定要**等到操作系统完成所有操作后才表示调用结束**，而非阻塞 I/O 是调用后立马返回，不用等操作系统内核完成操作。

对前者而言，在操作系统进行 I/O 的操作的过程中，我们的应用程序其实是一直处于等待状态的，什么都做不了。那如果换成`非阻塞I/O`，调用返回后我们的 nodejs 应用程序可以完成其他的事情，而操作系统同时也在进行 I/O。这样就把等待的时间充分利用了起来，提高了执行效率，但是同时又会产生一个问题，nodejs 应用程序怎么知道操作系统已经完成了 I/O 操作呢？

为了让 nodejs 知道操作系统已经做完 I/O 操作，需要重复地去操作系统那里判断一下是否完成，这种重复判断的方式就是`轮询`。对于轮询而言，有以下这么几种方案:

1. 一直轮询检查I/O状态，直到 I/O 完成。这是最原始的方式，也是性能最低的，会让 CPU 一直耗用在等待上面。其实跟阻塞 I/O 的效果是一样的。

2. 遍历文件描述符(即 文件I/O 时操作系统和 nodejs 之间的文件凭证)的方式来确定 I/O 是否完成，I/O完成则文件描述符的状态改变。但 CPU 轮询消耗还是很大。

3. epoll模式。即在进入轮询的时候如果I/O未完成CPU就休眠，完成之后唤醒CPU。

总之，CPU要么重复检查I/O，要么重复检查文件描述符，要么休眠，都得不到很好的利用，我们希望的是:

> nodejs 应用程序发起 I/O 调用后可以直接去执行别的逻辑，操作系统默默地做完 I/O 之后给 nodejs 发一个完成信号，nodejs 执行回调操作。

这是理想的情况，也是异步 I/O 的效果，那如何实现这样的效果呢？

## 异步 I/O 的本质

Linux 原生存在这样的一种方式，即(AIO), 但两个致命的缺陷:

1. 只有 Linux 下存在，在其他系统中没有异步 I/O 支持。
2. 无法利用系统缓存。

## nodejs中的异步 I/O 方案

是不是没有办法了呢？在单线程的情况下确实是这样，但是如果把思路放开一点，利用多线程来考虑这个问题，就变得轻松多了。我们可以让一个进程进行计算操作，另外一些进行 I/O 调用，I/O 完成后把信号传给计算的线程，进而执行回调，这不就好了吗？没错，**异步 I/O 就是使用这样的线程池来实现的**。
nodejs单线程通过非阻塞异步回调进程处理多个任务，不支持多线程，但现在已经不成立了。在 Node.js 10.15.0 中，有一个名为工作线程（worker threads）的新模块可用于实现多线程。

交给操作系统



总结 :

1. `阻塞`和`非阻塞` I/O 其实是针对操作系统内核而言的。阻塞 I/O 的特点就是一定要**等到操作系统完成所有操作后才表示调用结束**，而非阻塞 I/O 是调用后立马返回，不用等操作系统内核完成操作。
2. nodejs中的异步 I/O 采用多线程的方式，由 `EventLoop`、`I/O 观察者`，`请求对象`、`线程池`四大要素相互配合，共同实现。

[进程与线程](http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html)
[参考链接](https://sanyuan0704.top/blogs/javascript/js-async/001.html)
[node.js的多线程与多进程](https://segmentfault.com/a/1190000021462627)
[理解Node.js中的"多线程" - 知乎](https://zhuanlan.zhihu.com/p/74879045)
[IO模型](https://cloud.tencent.com/developer/article/1684951)