---
title: 浏览器工作原理的笔记
tags: ["浏览器工作原理"]
创建时间: 星期一, 九月 19日 2022, 10:40:20 晚上
修改时间: 星期五, 九月 23日 2022, 12:27:07 凌晨
---
#浏览器

# 浏览器工作原理的笔记


## 运行

运行chrome打开一个页面，会执行四个进程。

- GPU
- 网络
- 浏览器
- 页面


## 进程与线程

### 并行处理

单线程是串行执行
多线程可以同时执行(并行处理)

### 线程

线程不能单独存在，它是由进程来**启动和管理的**。

### 进程

一个进程是一个程序的**运行实例**。

启动一个程序时，操作系统会为该程序创建一块内存。用来存放代码、运行中的数据和一个执行任务的主线程。把这个环境称为进程。

### 区分

线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率。

#### 4个特点

1. 进程中任意一个线程执行出错，都会导致整个进程的崩塌。
2. 线程之间共享进程中的数据。
3. 当一个进程关闭后，操作系统会**回收**进程所占用的内存。
4. 进程之间的内容相互隔离。


## 单进程浏览器时代

> 单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里。
> 模块包括: 网络、插件、JavaScript运行环境、渲染引擎和页面等。

### 产生的问题

1. 不稳定

> 早期浏览器借助于插件来实现web视频、web游戏等强大功能。但是插件是最容易出现问题的模块。一个插件的意外崩溃会引起整个浏览器的崩溃。
> 渲染引擎也是不稳定。通常一些复杂的JavaScript代理就有可能引起渲染引起模块的崩溃。

2. 不流畅

> 同一时刻只能有一个模块运行。
> 一个无限循环的JavaScript脚本执行时，它会独占整个线程。这样导致其他运行在该线程中的模块没有机会被执行。

3. 不安全

> 插件可以使用 C/C++ 等代码编写，通过插件可以获取到操作系统的任意资源，当你在页面
运行一个插件时也就意味着这个插件能完全操作你的电脑。


以上这些就是当时浏览器的特点，不稳定，不流畅，而且不安全。这是一段不堪回首的过
去，也许你没有经历过，不过你可以想象一下这样的场景：当你正在用浏览器打开多个页面
时，突然某个页面崩溃了或者失去响应，随之而来的是整个浏览器的崩溃或者无响应。

## 早期多进程浏览器时代

Chrome 的页面是运行在单独的渲染进程中的，同时页面里的插件也是
运行在单独的插件进程之中，而进程之间是通过 IPC 机制进行通信

### 解决不稳定的问题

由于进程是相互隔离的，所以当一个页面或者插件崩溃
时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面，这就
完美地解决了页面或者插件的崩溃会导致整个浏览器崩溃，也就是不稳定的问题。

### 解决不流畅的问题

JavaScript 也是运行在渲染进程中
的，所以即使 JavaScript 阻塞了渲染进程，影响到的也只是当前的渲染页面，而并不会影
响浏览器和其他页面，因为其他页面的脚本是运行在它们自己的渲染进程中的。所以当我们
**再在 Chrome 中运行上面那个死循环的脚本时，没有响应的仅仅是当前的页面**。

> 对于内存泄漏的解决方法那就更简单了，因为当关闭一个页面时，整个渲染进程也会被关
闭，之后该进程所占用的内存都会被系统回收，这样就轻松解决了浏览器页面的内存泄漏问
题。

### 解决不安全的问题

采用多进程架构的额外好处是可以使
用安全沙箱，你可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，
但是不能在你的硬盘上写入任何数据，也不能在敏感位置读取任何数据，例如你的文档和桌
面。Chrome 把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里
面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。


## 目前多进程架构

⚠️upload failed, check dev console

最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个
GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。


- **浏览器进程**。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
- **渲染进程**。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，
排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会
为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
- **GPU 进程**。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷
是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘
制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了
GPU 进程。
- **网络进程**。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面
的，直至最近才独立出来，成为一个单独的进程。
- **插件进程**。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保
证插件进程崩溃不会对浏览器和页面造成影响。


> 打开一个页面，至少4个进程
> - 浏览器进程
> - 网络进程
> - 渲染进程
> - GPU进程
> - (若有装插件，还有插件进程)


### 两面性

> 虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不
可避免地带来了一些问题

1. 更高的资源占用
2. 更复杂的体系架构
> 浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已
经很难适应新的需求了


## 未来面向服务的架构

面向服务的架构(Services Oriented Architecture)(SOA)

> 原来的各
种模块会被重构成独立的服务（Service），每个服务（Service）都可以在独立的进程中运
行，访问服务（Service）必须使用定义好的接口，通过 IPC 来通信，从而构建一个更内
聚、松耦合、易于维护和扩展的系统，更好实现 Chrome 简单、稳定、高速、安全的目
标。


Chrome 最终要把 UI、数据库、文件、设备、网络等模块重构为基础服务，类似操作系统
底层服务，下面是 Chrome“面向服务的架构”的进程模型图：






## TCP协议：如何保证页面文件能被完整送达浏览器？

衡量Web页面性能的一个重要指标**FP** (First Paint), 从页面加载到首次开始绘制的时长。

影响FP的一个重要因素：**网络加载速度**。

需要对网络有充分的了解。关键要对网络协议有深刻的认识。HTTP、WebSocket。都是基于TCP/IP


### IP (网络层)

计算机的地址就称为 IP 地址，访问任何网站实际上只是你的计算机向另外一台计算机请求信息。

如果要将一个**数据包**从主机A发给主机B，在传输前，数据包会被附加上主机B的**IP地址信息**，这样在传输的过程中才能正确的寻址。额外地，数据包上还会附加上主机A 本身的 IP 地址，有了这些信息主机 B 才可以回复信息给主机 A。这些附加的信息会被装进一个叫 IP 头的数据结构里。

IP 头是 IP 数据包开头的信息，包含 IP 版本、源 IP 地址、目标 IP 地址、生存时间等信息。

> 知道谁发，和知道发送给谁。

### UDP (传输层)

用户数据包协议（User Datagram Protocol） UDP

UDP 中一个最重要的信息是端口号，端口号其实就是一个数字，每个想访问网络的程序都需要绑定一个端口号。通过端口号 UDP 就能把指定的数据包发送给指定的程序了，所以IP通过 IP 地址信息把数据包发送给指定的电脑，**而 UDP 通过端口号把数据包分发给正确的程序**。

和 IP 头一样，**端口号会被装进 UDP 头里面**，UDP 头再和原始数据包合并组成新的UDP 数据包。UDP 头中除了目的端口，还有源端口号等信息

在使用 UDP 发送数据时，**有各种因素会导致数据包出错**，虽然 UDP 可以校验数据是否正确，**但是对于错误的数据包**，UDP 并不提供重发机制，只是丢弃当前的包，而且 UDP 在发送之后也无法知道是否能达到目的地。

虽说UDP 不能保证数据可靠性，但是传输速度却非常快，所以 UDP 会应用在一些关注速度、但不那么严格要求数据完整性的领域，如在线视频、互动游戏等。

> 不可靠，不能保证数据可靠性，但是速度快。发了就行。UDP有校验，但是对于错误的包，采用丢弃，没有重发机制。

- 数据包在传输过程中容易丢失
- 大文件会被拆分成很多小的数据包来传输，这些小的数据包会经过不同的路由，并在不同的时间到达接收端，而 UDP 协议并不知道如何组装这些数据包，从而把这些数据包还原成完整的文件。

### TCP (传输层)

TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。

- 对于数据包丢失的情况，TCP 提供重传机制；
- TCP 引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。

> 充分解决了UDP带来的问题，但因为做这些事，需要时间。所以速度没有UDP快。

和 UDP 头一样，TCP 头除了包含了目标端口和本机端口号外，还提供了用于**排序的序列号**，以便接收端通过序号来**重排数据包**。

TCP 单个数据包的传输流程和 UDP 流程差不多，不同的地方在于，**通过 TCP 头的信息保证了一块大的数据传输的完整性**。

一个完整的 TCP 连接的生命周期包括了三个阶段。

- 建立连接
- 传输数据
- 断开连接


#### 三次握手(建立连接)

TCP 提供面向连接的通信传输。面向连接是指在数据通信开始之前先做好两端之间的准备工作。所谓三次握手，是指在建立一个 TCP 连接时，客户端和服务器总共要发送三个数据包以确认连接的建立。

#### 传输数据阶段

接收端需要**对每个数据包进行确认操作**，也就是接收端在接收到数据包之后，需要发送确认数据包给发送端。所以当发送端发送了一个数据包之后，在规定时间内没有接收到接收端反馈的确认消息，**则判断为数据包丢失，并触发发送端的重发机制**。同样，一个大的文件在传输过程中会被拆分成很多小的数据包，这些数据包到达接收端后，接收端会按照 TCP 头中的序号为其排序，从而保证组成完整的数据。

#### 四次分手(断开连接)

数据传输完毕之后，就要终止连接了，涉及到最后一个阶段“四次挥手”来保证双方都能断开连接。

TCP 为了保证数据传输的可靠性，牺牲了数据包的传输速度，因为“三次握手”和“数据包校验机制”等把传输过程中的数据包的**数量提高了一倍**。

互联网中的数据是通过数据包来传输的，数据包在传输过程中容易丢失或出错。

- IP 负责把数据包送达目的主机。
- UDP 负责把数据包送达具体应用
- 而 TCP 保证了数据完整地传输，它的连接可分为三个阶段：**建立连接**、**传输数据**和**断开连接**。


## HTTP

HTTP 协议，正是建立在 TCP 连接基础之上的。HTTP 是一种允许**浏览器向服务器获取资源的协议**，是 Web 的基础。

> 允许浏览器向服务器获取资源的协议。 一个应用层的协议。


#### 浏览器发起HTTP请求流程

1. 构建请求

   首先，浏览器构建请求行
   ```txt
   GET /index.html HTTP1.1
   ```

2. 查找缓存

   在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。其中，浏览器缓存是**一种在本地保存资源副本**，以供下次请求时直接使用的技术。
   当浏览器发现请求的资源已经在浏览器缓存中存有副本，它会拦截请求，返回该资源的副本，并直接结束请求，**而不会再去源服务器重新下载**。这样做的好处有：
   - 缓解服务器端压力，提升性能（获取资源的耗时更短了）；
   - 对于网站来说，缓存是实现快速资源加载的重要组成部分。
   当然，如果缓存查找失败，就会进入网络请求过程了。

3. 准备IP地址和端口

   HTTP与IP的关系：
   HTTP 协议作为应用层协议，**用来封装请求的文本信息**；并**使用TCP/IP 作传输层协议**将它**发到网络**上，所以在 HTTP 工作开始之前，浏览器需要通过 TCP 与服务器建立连接。

   > HTTP 的内容是通过 TCP 的传输数据阶段来实现的

   倒推法：
   HTTP网络请求建立在TCP连接，而TCP连接的第一步就是需要准备IP和端口号。

   那么获取端口号：DNS(Domain Name System)域名系统：一个服务，负责把域名和 IP 地址做一一映射关系。

   这样一路推导下来，你会发现在第一步浏览器会**请求 DNS 返回域名对应的 IP**。当然浏览器还提供了DNS 数据缓存服务，如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用，这样也会减少一次网络请求。

   拿到 IP 之后，接下来就需要获取端口号了。通常情况下，如果 URL 没有特别指明端口号，那么 HTTP 协议默认是 80 端口。

   > HTTP -> TCP -> IP port -> DNS

4. 等待TCP队列

   现在已经把端口和 IP 地址都准备好了，那么下一步是不是可以建立 TCP 连接了呢？答案依然是“不行”。Chrome 有个机制，**同一个域名同时最多只能建立 6 个 TCP 连接**，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。**当然，如果当前请求数量少于 6，会直接进入下一步，建立 TCP 连接。**

5. 建立TCP连接

   排队等待结束之后，终于可以快乐地和服务器握手了，在 HTTP 工作开始之前，浏览器通过 TCP 与服务器建立连接。而 TCP 的工作方式，我在上一篇文章中已经做过详细介绍了，如果有必要，你可以自行回顾下，这里我就不再重复讲述了。

6. 发起HTTP请求

   一旦建立了 TCP 连接，浏览器就可以和服务器进行通信了。而 HTTP 中的数据正是在这个通信过程中传输的。

   - 请求行
   - 请求头
   - 请求体 (POST)

   首先浏览器会向服务器发送请求行，它包括了**请求方法**、请求 URI（Uniform ResourceIdentifier）和 HTTP 版本协议。

   ```txt
   GET /index.html HTTP1.1
   ```



#### 服务器端处理HTTP请求流程

1. 返回请求
   一旦服务器处理结束，便可以返回数据给浏览器了。你可以通过工具软件 curl 来查看返回请求数据，具体使用方法是在命令行中输入以下命令：

   ```bash
    curl -i https://time.geekbang.org/
   ```

> -i是为了返回响应行、响应头和响应体的数据

  - 响应行 (HTTP协议、状态码(2xx、3xx、4xx、5xx))
  - 响应头 (服务器自身的一些信息、服务器要在客户端保存的 Cookie 等信息)
  - 响应体

2. 断开连接
   一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。不过如果浏览器或者服务器在其头信息中加入了

   ```
   Connection:Keep-Alive 
   ```
   那么 TCP 连接在发送后将仍然保持打开状态，这样浏览器就可以继续通过同一个 TCP 连接发送请求。保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。

  比如，一个 Web 页面中内嵌的图片就都来自同一个 Web 站点，如果初始化了一个持久连接，你就可以复用该连接，以请求其他资源，而不需要重新再建立新的 TCP 连接。

3. 重定向
   响应行返回的状态码是 301
   状态 301 就是告诉浏览器，我需要重定向到另外一个网址，而需要重定向的网址正是包含在响应头的 Location 字段中，接下来，浏览器获取 Location 字段中的地址，并使用该地址重新导航，这就是一个完整重定向的执行流程。



### 2个问题

1. 为什么通常在第一次访问一个站点时，打开速度很慢，当再次访问这个站点时，速度就很快了？
   
2. 当登录过一个网站之后，下次再访问该站点，就已经处于登录状态了，这是怎么做到的呢？